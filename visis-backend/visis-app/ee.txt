Certainly! The issue you're experiencing with the genre being set to `"Unknown"` is primarily due to the genre detection logic relying on English keywords, while your documents may be in other languages like Dutch. Since the extracted text is in a different language, the keywords in English are not found, resulting in the genre remaining `"Unknown"`.

To improve the accuracy of genre detection, especially when dealing with multiple languages, you have a few options:

1. **Translate the Text to English Before Genre Detection**:
   
   - **Use Amazon Translate** to translate the extracted text into English.
   - Perform genre detection on the translated text using your existing English keywords.

2. **Expand Genre Keywords to Include Other Languages**:

   - Add keywords in multiple languages for each genre.
   - This approach can be labor-intensive and may not cover all possible languages.

3. **Leverage AWS Comprehend for Topic Modeling**:

   - Use AWS Comprehend's topic modeling or entity recognition to infer the genre.
   - AWS Comprehend supports multiple languages for certain features.

4. **Use Machine Learning Models for Text Classification**:

   - Implement a machine learning model trained on multi-language datasets to classify text into genres.
   - This requires additional effort to train and deploy the model.

Given that you're already using AWS services, **Option 1 (Using Amazon Translate)** is the most straightforward and effective solution. It allows you to continue using your existing genre detection logic with minimal changes.

---

## **Implementing the Solution**

### **1. Integrate Amazon Translate**

First, you need to integrate Amazon Translate into your document processing pipeline.

**Import the Boto3 Client for Translate:**

```python
import boto3
```

**Initialize the Translate Client:**

```python
translate_client = boto3.client('translate', region_name=settings.REGION_NAME)
```

### **2. Modify Your `upload_document` Function**

Update your `upload_document` function to include the translation step before genre detection.

**Updated Code Snippet:**

```python
# After mapping the detected language to full name
full_language_name = map_language_code_to_supported(detected_language)
document.detected_language = full_language_name

# Generate description (in original language)
document.description = text[:200].strip()

# Translate text to English if necessary
if detected_language != 'en':
    # Use Amazon Translate to translate the text to English
    try:
        translation = translate_client.translate_text(
            Text=text,
            SourceLanguageCode=detected_language,
            TargetLanguageCode='en'
        )
        translated_text = translation.get('TranslatedText', '')
        logger.info(f"Translation successful for document {document.id}")
    except Exception as e:
        logger.error(f"Error translating text for document {document.id}: {str(e)}")
        translated_text = text  # Fallback to original text if translation fails
else:
    translated_text = text

# Infer genre from translated text
genre = "Unknown"
for key, keywords in genre_keywords.items():
    if any(keyword in translated_text.lower() for keyword in keywords):
        genre = key
        break
document.genre = genre
```

### **3. Update Imports and Initialization**

Make sure to import the necessary libraries and initialize the Translate client at the beginning of your file.

```python
# Import statements
import boto3
# ... other imports ...

# Initialize AWS clients
translate_client = boto3.client('translate', region_name=settings.REGION_NAME)
```

### **4. Handle Exceptions and Logging**

Ensure that you have proper exception handling and logging to catch any errors during translation.

```python
try:
    # Translation code...
except Exception as e:
    logger.error(f"Error translating text for document {document.id}: {str(e)}")
    translated_text = text  # Fallback to original text
```

---

## **Full Updated `upload_document` Function**

Here's the updated `upload_document` function with the translation step included:

```python
@router.post("/", response_model=DocumentResponse, status_code=status.HTTP_201_CREATED)
def upload_document(
    file: UploadFile = File(...),
    is_public: bool = False,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user),
):
    try:
        start_time = time.time()

        # Read the uploaded file content
        file_content = file.file.read()

        # Allowed content types
        ALLOWED_CONTENT_TYPES = ["application/pdf", "image/png", "image/jpeg", "text/plain"]

        # Check file type
        if file.content_type not in ALLOWED_CONTENT_TYPES:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Unsupported file type for processing.",
            )

        # Generate the file key for S3
        file_key = f"{settings.S3_FOLDER_NAME}/{user.id}/{file.filename}"

        # Upload the file to S3
        s3_url = s3_handler.upload_file(
            file_obj=io.BytesIO(file_content),
            bucket=settings.S3_BUCKET_NAME,
            key=file_key,
            content_type=file.content_type,
        )
        if not s3_url:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to upload file to S3",
            )

        # Create a database record for the document
        document_data = DocumentCreate(
            title=file.filename,
            author=user.username,
            file_type=file.content_type,
            file_key=file_key,
            url=s3_url,
            is_public=is_public,
        )
        document = create_document(
            db=db,
            document_data=document_data,
            user_id=user.id,
            file_key=file_key,
            file_size=len(file_content),
        )

        # Update processing status to "processing"
        document.processing_status = "processing"
        db.commit()

        # Start processing the document
        try:
            with ThreadPoolExecutor(max_workers=13) as executor:
                # Determine file type and process accordingly
                if document.file_type == "application/pdf":
                    text, detected_language = ocr_service.extract_text_from_pdf(
                        bucket_name=settings.S3_BUCKET_NAME, file_key=document.file_key
                    )
                elif document.file_type.startswith("image/"):
                    text, detected_language = ocr_service.extract_text_from_image(
                        bucket_name=settings.S3_BUCKET_NAME, file_key=document.file_key
                    )
                    # Rekognition for tags
                    tags = rekognition_service.detect_labels(
                        bucket_name=settings.S3_BUCKET_NAME, file_key=document.file_key
                    )
                    if isinstance(tags, str):
                        tags = tags.split(", ")
                    if not tags:
                        tags = ["No tags detected"]
                    document.tags = tags
                elif document.file_type == "text/plain":
                    text = file_content.decode("utf-8")
                    detected_language = "en"
                else:
                    raise HTTPException(
                        status_code=status.HTTP_400_BAD_REQUEST,
                        detail="Unsupported file type for processing.",
                    )

                if not text.strip():
                    raise Exception("No text found in the document.")

                # Map detected language to full name
                full_language_name = map_language_code_to_supported(detected_language)
                document.detected_language = full_language_name

                # Generate description (in original language)
                document.description = text[:200].strip()

                # Translate text to English if necessary
                if detected_language != 'en':
                    try:
                        translation = translate_client.translate_text(
                            Text=text,
                            SourceLanguageCode=detected_language,
                            TargetLanguageCode='en'
                        )
                        translated_text = translation.get('TranslatedText', '')
                        logger.info(f"Translation successful for document {document.id}")
                    except Exception as e:
                        logger.error(f"Error translating text for document {document.id}: {str(e)}")
                        translated_text = text  # Fallback to original text
                else:
                    translated_text = text

                # Infer genre from translated text
                genre = "Unknown"
                for key, keywords in genre_keywords.items():
                    if any(keyword in translated_text.lower() for keyword in keywords):
                        genre = key
                        break
                document.genre = genre

                # Continue with the rest of your processing (TTS, audiobook creation, etc.)
                # ...

        except Exception as processing_error:
            logger.error(f"Error processing document {document.id}: {str(processing_error)}")
            document.processing_status = "failed"
            document.processing_error = str(processing_error)
            db.commit()
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Document processing failed: {str(processing_error)}",
            )

    except HTTPException as http_exc:
        logger.error(f"HTTP error uploading document: {str(http_exc.detail)}")
        raise http_exc
    except Exception as e:
        logger.error(f"Error uploading document: {str(e)}")
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to upload document",
        )
```

---

## **Explanation**

- **Translation Step**:
  
  - We check if the detected language is not English (`'en'`).
  - If not, we use Amazon Translate to translate the text into English.
  - We handle any exceptions during translation and fallback to the original text if necessary.

- **Genre Detection**:

  - We perform genre detection on the translated text.
  - Since the text is now in English, your existing keyword-based genre detection will be more effective.

- **Preserving Original Description**:

  - The `description` field still uses the original text (first 200 characters).
  - This ensures that the description matches the language of the original document.

---

## **Benefits of This Approach**

- **Improved Genre Detection**:

  - By translating the text to English, you increase the chances of matching the keywords.
  - This reduces the occurrences of the genre being `"Unknown"`.

- **Multilingual Support**:

  - Your application becomes more robust in handling documents in various languages.
  - Users uploading documents in languages other than English will have a better experience.

- **Minimal Changes**:

  - The changes required are minimal and integrate seamlessly with your existing codebase.
  - You continue to leverage AWS services, keeping your technology stack consistent.

---

## **Considerations**

### **Cost**

- **AWS Translate Costs**:

  - Using Amazon Translate will incur additional costs based on the amount of text translated.
  - Monitor your AWS usage and ensure it aligns with your budget.

### **Performance**

- **Processing Time**:

  - Translation may add additional time to the document processing pipeline.
  - In most cases, the added time is negligible, but you should test to ensure acceptable performance.

### **Error Handling**

- **Translation Failures**:

  - Ensure you have proper exception handling in case the translation service fails.
  - Fallback to the original text and handle genre detection accordingly.

### **Privacy and Compliance**

- **Data Handling**:

  - Be mindful of the data you're sending to AWS Translate, especially if it contains sensitive information.
  - Ensure compliance with any data protection regulations applicable to your application.

---

## **Alternative Approaches**

### **1. Expand Genre Keywords to Include Multiple Languages**

- **Pros**:

  - Directly matches keywords in the original language.
  - No additional costs from translation services.

- **Cons**:

  - Requires extensive effort to gather keywords for each genre in multiple languages.
  - Not scalable as you add support for more languages.

### **2. Use Machine Learning Models**

- **Pros**:

  - Can provide more accurate genre classification.
  - Models can be trained on multilingual datasets.

- **Cons**:

  - Requires significant development effort to train and deploy models.
  - May require additional resources and infrastructure.

### **3. Use AWS Comprehend for Topic Modeling**

- **Pros**:

  - AWS Comprehend supports multiple languages for certain features.
  - Can extract entities, key phrases, and topics.

- **Cons**:

  - Topic modeling in AWS Comprehend supports limited languages.
  - May require adjustments to your processing pipeline.

---

## **Conclusion**

By integrating Amazon Translate into your document processing pipeline, you enhance the genre detection mechanism, allowing it to work effectively with documents in various languages. This approach provides a balance between improving functionality and maintaining simplicity in your codebase.

---

**Feel free to implement this solution and let me know if you encounter any issues or have further questions!**





####paystack


Payment Channels
In a nutshell

Paystack enables you accept payments from customers using different payment channels such as: cards, mobile money accounts, QR codes, directly from their bank account or USSD.

If you use the the Popup or Redirect method, the paying customer will be shown all the payment methods selected on your dashboard. But if you don't want to use either option, you can initiate all the different payment channels directly from your server using the Charge API.
What channels are available?

Card payment channels are available on all Paystack accounts, while the other payment channels are only available in countries where they are supported.
Cards
Feature Availability

The Card API is available in all our markets for businesses that are PCI Compliant. If you intend to use this API, you should check the compliance requirements outlined below and reach out to us.

The Cards API allows you to send card details securely and compliantly to our server from your custom checkout. With this, PCI-DSS complaint businesses can build bespoke checkout experiences without compromising on security.

The sensitivity of card details requires businesses to adhere to the Payment Card Industry Data Security Standards (PCI-DSS), to ensure that they are securely processed. Paystack adheres to this as a PCI Level 1 Service Provider, allowing non-complaint businesses to use our Checkout and Mobile SDKs for card payments
Compliance Requirements

PCI-DSS certification documents can only be issued on behalf of the PCI Council by an accredited Qualified Security Assessor (QSA) after an audit.

The documents issued by the council are the Attestation of Compliance (AOC) and Report on Compliance. These documents are only valid for one year from the dated they were signed. We require you to submit these documents before you’re allowed to use this API.

For Paystack, a valid AOC needs to show the following:

    Issued after an audit by a QSA
    Signed off by a QSA
    Within one year of issue date
    Has the PCI SSC logo on the cover page
    Adheres to at least version 3.2.1 of PCI-DSS 

If you have met the criteria above please submit your documents to support@paystack.com or through your Paystack relationship manager and we'll grant access to the APIs.
Bank accounts
Feature availability

This feature is currently available to businesses in Nigeria.

The Pay with Bank feature allows customers pay through internet banking portal or by providing their bank account number and authenticating using an OTP sent to their phone or email.

This is different from Bank Transfers where customers transfer money into a bank account.
Collect bank details

To collect bank details, you would need to prompt the user to select their bank and enter their account number. To fetch the list of supported banks, make a GET request to the list banksAPI endpoint, with the additional filter pay_with_bank=true.

The banks can be listed in a dropdown or any other format that allows the user to easily pick their bank of choice.
Create a charge

Send email, amount, metadata, bank (an object that includes the code of the bank and account_number supplied by customer) and birthday to our Charge endpoint to start.
Show Response

curl https://api.paystack.co/charge

-H "Authorization: Bearer YOUR_SECRET_KEY"

-H "Content-Type: application/json"

-d '{ "email": "customer@email.com", 

      "amount": "10000", 

      "bank": {

        "code": "057", 

        "account_number": "0000000000" 

      }

    }'

-X POST

If the selected bank is Kuda, you need to make use of phone and token instead of account_number in the bank object:
Show Response

curl https://api.paystack.co/charge

-H "Authorization: Bearer YOUR_SECRET_KEY"

-H "Content-Type: application/json"

-d '{ "email": "customer@email.com", 

      "amount": "10000", 

      "bank": {

        "code": "50211", 

        "phone": "+2348100000000",

        "token": "123456"

      }

    }'

-X POST


When the API call is made, the value of the data.status key is pending as the payment is being processed in the background. The data.status then updates to either, success or failed depending on whether the transaction was successful or not.
Pay with Transfer
Feature availability

This feature is currently available to businesses in Nigeria and merchants need to reach out to support@paystack.com to enable it on their integration.

Pay with Transfer (PwT) is a feature that allow merchants or businesses create temporary bank accounts that customers can use to pay for goods or services. The account number is generated and tied to the current customer’s transaction. The account number becomes invalid after the customer’s transaction or when it exceeds it’s expiry time.
Create a PwT charge

At the point of payment, you initiate a request to the Create ChargeAPI endpoint, passing the email, amount and bank_transfer object. The bank_transfer object takes the account_expires_at which is used to set the expiry of an account number for a transaction:
Show Response

#!/bin/sh


url="https://api.paystack.co/charge"

authorization="Authorization: Bearer YOUR_SECRET_KEY"

content_type="Content-Type: application/json"

data='{ 

  "email": "another@one.com", 

  "amount": "25000", 

  "bank_transfer": {

    "account_expires_at": "2023-09-12T13:10:00Z"

  } 

}'


curl "$url" -H "$authorization" -H "$content_type" -d "$data" -X POST

Bank Transfer Param	Type	Description
account_expires_at	String	Account validity period in ISO 8601 format (YYYY-MM-DDThh:mm:ssZ). Minimum time is 15 mins from the current time and maximum time is 8 hours from the current time. You can also set this to null so we automatically set it to 8 hours from the current time.
Account expiry

If the difference between account_expires_at and the current time is less than 15 mins we will default to a 15 mins. If the difference between account_expires_at and the current time exceeds 8 hours we will default to 8 hours.
Verifying transfer
Receiving notifications

To receive notifications, you need to implement a webhook URL and set the webhook URL on your Paystack Dashboard

A bank transfer is initiated by a customer and processed by their bank. In order to confirm payment, you need to implement webhooks and listen to the following events:
Event	Description
charge.success	This is sent when the customer’s transfer is successful.
bank.transfer.rejected	This is sent when the customer either sent an incorrect amount or when the customer has been flagged by our fraud system.

    Charge SuccessfulTransfer Rejected

{

  "event": "charge.success",

  "data": {

    "id": 3104021987,

    "domain": "test",

    "status": "success",

    "reference": "zuz8ggd1ro",

    "amount": 25000,

    "message": null,

    "gateway_response": "Approved",

    "paid_at": "2023-09-12T13:29:09.000Z",

    "created_at": "2023-09-12T13:27:50.000Z",

    "channel": "bank_transfer",

    "currency": "NGN",

    "ip_address": "172.91.42.100",

    "metadata": "",

    "fees_breakdown": null,

    "log": null,

    "fees": 375,

    "fees_split": null,

    "authorization": {

      "authorization_code": "AUTH_q5nfynycgm",

      "bin": "008XXX",

      "last4": "X553",

      "exp_month": "09",

      "exp_year": "2023",

      "channel": "bank_transfer",

      "card_type": "transfer",

      "bank": null,

      "country_code": "NG",

      "brand": "Managed Account",

      "reusable": false,

      "signature": null,

      "account_name": null,

      "sender_country": "NG",

      "sender_bank": null,

      "sender_bank_account_number": "XXXXXXX553",

      "sender_name": "Jadesola Oluwashina",

      "narration": "Channel Tests"

    },

    "customer": {

      "id": 138496675,

      "first_name": null,

      "last_name": null,

      "email": "another@one.com",

      "customer_code": "CUS_1eq06yu8efl8u63",

      "phone": null,

      "metadata": null,

      "risk_action": "default",

      "international_format_phone": null

    },

    "plan": {},

    "subaccount": {},

    "split": {},

    "order_id": null,

    "paidAt": "2023-09-12T13:29:09.000Z",

    "requested_amount": 25000,

    "pos_transaction_data": null,

    "source": {

      "type": "api",

      "source": "merchant_api",

      "entry_point": "charge",

      "identifier": null

    }

  }

}

Alternatively, you can use the Check Pending ChargeAPI endpoint to manually verify the status of the transaction.
USSD

This Payment method is specifically for Nigerian customers. Nigerian Banks provide USSD services that customers use to perform transactions, and we've integrated with some of them to enable customers complete payments.

The Pay via USSD channel allows your Nigerian customers to pay you by dialling a USSD code on their mobile device. This code is usually in the form of * followed by some code and ending with #. The user is prompted to authenticate the transaction with a PIN and then it is confirmed.

All you need to initiate a USSD charge is the customer email and the amount to charge.

When the user pays, a response will be sent to your webhook. Hence, for this to work properly as expected, webhooks must be set up on your Paystack Dashboard.
Create a charge

Send an email and amount to the chargeAPI endpoint. Specify the USSD type you are charging as well.

Below are all the USSD types we support. We'll add to list as we have more:
Bank	Type
Guaranty Trust Bank	737
United Bank of Africa	919
Sterling Bank	822
Zenith Bank	966
Show Response

curl https://api.paystack.co/charge

-H "Authorization: Bearer YOUR_SECRET_KEY"

-H "Content-Type: application/json"

-d '{ "email": "some@body.nice", 

      "amount":"10000",

      "ussd": {

        "type": "737"

      },

      "metadata": {

        "custom_fields":[{

          "value": "makurdi",

          "display_name": "Donation for",

          "variable_name": "donation_for"

        }]

      }

    }'

-X POST

When a charge is made, the default response provides a USSD code for the customer to dial to complete the payment.
Handle response

When the user completes payment, a response is sent to the merchant’s webhook. Hence, for this to work properly as expected, webhooks must be set up for the merchant..

The charge.success event is raised on successful payment. The sample response to be sent to the user’s webhook would look like:

    JSON

{

  "event": "charge.success",

  "data": {

    "id": 53561,

    "domain": "live",

    "status": "success",

    "reference": "2ofkbk0yie6dvzb",

    "amount": 150000,

    "message": "madePayment",

    "gateway_response": "Payment successful",

    "paid_at": "2018-06-25T12:42:58.000Z",

    "created_at": "2018-06-25T12:38:59.000Z",

    "channel": "ussd",

    "currency": "NGN",

    "ip_address": "54.246.237.22, 162.158.38.185, 172.31.15.210",

    "metadata": "",

    "log": null,

    "fees": null,

    "fees_split": null,

    "authorization": {

      "authorization_code": "AUTH_4c6mhnmmeusp4yd",

      "bin": "XXXXXX",

      "last4": "XXXX",

      "exp_month": "05",

      "exp_year": "2018",

      "channel": "ussd",

      "card_type": "offline",

      "bank": "Guaranty Trust Bank",

      "country_code": "NG",

      "brand": "offline",

      "reusable": false,

      "signature": null,

      "account_name": null

    },

    "customer": {

      "id": 16200,

      "first_name": "John",

      "last_name": "Doe",

      "email": "customer@email.com",

      "customer_code": "CUS_bpy9ciomcstg55y",

      "phone": "",

      "metadata": null,

      "risk_action": "default"

    },

    "plan": {},

    "subaccount": {},

    "paidAt": "2018-06-25T12:42:58.000Z"

  }

}

USSD recurring charge

Charging returning customers directly is not currently available. Simply call the endpoint to start a new transaction.
Mobile money
Feature Availability

This feature is only available to businesses in Ghana and Kenya.

The Mobile Money channel allows your customers to pay you by using their phone number enabled for mobile money. At the point of payment, the customer is required to authorize the payment on the mobile phones.

Since payment is completed offline, you need to have a webhook URL  which we’ll use to send the final status of the payment to your server.
Create a charge

To initiate a charge for mobile money, you need to make a POST request to the chargeAPI passing the customer’s email, amount, and mobile_money object:

curl https://api.paystack.co/charge

-H "Authorization: Bearer YOUR_SECRET_KEY"

-H "Content-Type: application/json"

-d '{ "amount": 100,

      "email": "customer@email.com",

      "currency": "GHS",

      "mobile_money": {

        "phone" : "0551234987",

        "provider" : "mtn"

      }

    }'

-X POST

Provider code

Here are the character codes for the supported mobile money providers:
Provider	Code	Country
MTN	mtn	Ghana
AirtelTigo	atl	Ghana
Vodafone	vod	Ghana
M-Pesa	mpesa	Kenya

On the successful creation of the charge, you need to handle the response based on the provider selected.
AirtelTigo and MTN

AirtelTigo and MTN requires the customer to complete the transaction process offline, the data.status field would be pay_offline, once you get this status, there's nothing left to do. You're expected to display the data.display_text to your user, and then listen for webhook for transaction notification or requery the verify transaction endpoint at interval.

Here is a sample response that requires the customer to complete the process offline:

    JSON

{

  "status": true,

  "message": "Charge attempted",

  "data": {

    "reference": "8nn5fqljd0suybr",

    "status": "pay_offline",

    "display_text": "Please complete authorization process on your mobile phone"

  }

}

Vodafone

For Vodafone, the customer is required to generate a voucher code by dialing the USSD code show in the data.display_text field, this voucher code should be collected and passed to the submit OTPAPI endpoint to authorize the transaction.

    JSON

{

  "status": true,

  "message": "Charge attempted",

  "data": {

    "reference": "r13havfcdt7btcm",

    "status": "send_otp",

    "display_text": "Please dial *110# to generate a voucher code. Then input the voucher"

  }

}

If the mobile money customer enters the otp on time and we are able to get a response just in time, we return the success response:

    JSON

{

  "message": "Charge attempted",

  "status": true,

  "data": {

    "amount": 100,

    "channel": "mobile_money",

    "created_at": "2018-11-17T14:39:56.000Z",

    "currency": "GHS",

    "domain": "live",

    "fees": 153,

    "gateway_response": "Approved",

    "id": 59333,

    "ip_address": "35.177.189.123, 162.158.155.220",

    "message": "madePayment",

    "paid_at": "2018-11-17T14:40:18.000Z",

    "reference": "l7lvu4y3xcka6zu",

    "status": "success",

    "transaction_date": "2018-11-17T14:39:56.000Z",

    "authorization": {

      "authorization_code": "AUTH_33lz7ev5tq",

      "bank": "MTN Mobile Money",

      "bin": "055XXX",

      "brand": "Mtn mobile money",

      "channel": "mobile_money",

      "country_code": "GH",

      "exp_month": 12,

      "exp_year": 9999,

      "last4": "X149",

      "reusable": false,

      "account_name": null

    },

    "customer": {

      "customer_code": "CUS_s3aa4mx0yyvrqye",

      "email": "customer@email.com",

      "id": 16763,

      "risk_action": "default"

    }

  }

}

If the transaction is started successfully and the pin is not entered on time, we return this:

    JSON

{

  "status": true,

  "message": "Charge attempted",

  "data": {

    "reference": "84oow6t0rf715g6",

    "status": "pending"

  }

}

M-Pesa
Feature Availability

When creating the request for M-Pesa, you need to ensure that the phone number is formatted using the country code. For example, 0710000000 should be sent as +254710000000.

With M-Pesa, the customer is required to use their PIN to authorize the payment. In the data object, we return a status of pay_offline and a display_text stating that the customer’s authorization is required to complete the payment:

    JSON

{

  "status": true,

  "message": "Charge attempted",

  "data": {

    "reference": "jq3psd5n96sprwl",

    "status": "pay_offline",

    "display_text": "Please complete authorization process on your mobile phone"

  }

}

Handle response

When the user completes payment, a response is sent to the merchant’s webhook. Hence, for this to work properly as expected, webhooks must be set up for the merchant.

The charge.success event is raised on successful payment. The sample response to be sent to the user’s webhook would look like:

    JSON

{

  "event": "charge.success",

  "data": {

    "id": 59214,

    "domain": "live",

    "status": "success",

    "reference": "gf4n3ykzj6a7u89",

    "amount": 100,

    "message": "madePayment",

    "gateway_response": "Approved",

    "paid_at": "2018-11-15T06:10:54.000Z",

    "created_at": "2018-11-15T06:10:32.000Z",

    "channel": "mobile_money",

    "currency": "GHS",

    "ip_address": "18.130.236.148, 141.101.99.73",

    "metadata": "",

    "log": null,

    "fees": 153,

    "fees_split": null,

    "authorization": {

      "authorization_code": "AUTH_0aqm8ddx6s",

      "bin": "055XXX",

      "last4": "X149",

      "exp_month": "12",

      "exp_year": "9999",

      "channel": "mobile_money",

      "card_type": "",

      "bank": "MTN Mobile Money",

      "country_code": "GH",

      "brand": "Mtn mobile money",

      "reusable": false,

      "signature": null,

      "account_name": "BoJack Horseman"

    },

    "customer": {

      "id": 16678,

      "first_name": "Babafemi",

      "last_name": "Aluko",

      "email": "customer@email.com",

      "customer_code": "CUS_2jk1i8ezoam49br",

      "phone": "",

      "metadata": null,

      "risk_action": "allow"

    },

    "plan": {},

    "subaccount": {},

    "subaccount_group": {},

    "paidAt": "2018-11-15T06:10:54.000Z"

  }

}

Charging returning customers directly is not currently available. Simply call the endpoint to start a new transaction. We have some test credentials that can be used to run some tests.
EFT

EFT payments are an instant bank transfer payment method where customers pay merchants through their internet banking interfaces. When the developer specifies an EFT provider, we do a redirect to the providers platform where the customer provides their payment details after which the payment is authorized.
Where is this available?

This feature is only available to South African customers.
Create a charge

You need to send the email, amount, currency, and the EFT provider to the chargeAPI endpoint:
Show Response

curl https://api.paystack.co/charge

-H "Authorization: Bearer YOUR_SECRET_KEY"

-H "Content-Type: application/json"

-d '{

      "amount": 5000,

      "currency": "ZAR",

      "email": "customer@email.com",

      "eft": {

        "provider": "ozow"

      }

}'

-X POST

Available Providers

Ozow is currently the only provider available.
Handle response

When the user completes payment, a response is sent to the merchant’s webhook. The merchant needs to setup webhooks to get the status of the payment. The charge.success event is raised on successful payment.
QR code

The QR option generates a QR code that allow customers to use a supported mobile app to complete payments.

When the customer scans the code, they authenticate on a supported app to complete the payment. When the user pays, a response will be sent to your webhook. This means that you need to implement and set a webhook URL on your Paystack Dashboard.
Create a charge

Send an email and amount to the chargeAPI endpoint along with a qr object. The qr object should contain a provider parameter, specifying the QR provider for the transaction. The available QR providers are:
Provider	Availability
scan-to-pay	South Africa
visa	Nigeria
Supported Apps

The scan-to-pay provider supports both SnapScan and Scan to Pay (formerly Masterpass) supported apps for completing a payment.
Show Response

curl https://api.paystack.co/charge

-H "Authorization: Bearer YOUR_SECRET_KEY"

-H "Content-Type: application/json"

-d '{ "amount": 100,

      "email": "customer@email.com",

      "currency": "NGN",

      "qr": {

        "provider" : "visa"

      }

    }'

-X POST

Handle response

When the user completes payment, a response is sent to the merchant’s webhook. Hence, for this to work properly as expected, webhooks must be set up for the merchant.

The charge.success event is raised on successful payment. The sample response to be sent to the user’s webhook would look like:

    JSON

{

  "event": "charge.success",

  "data": {

    "id": 59565,

    "domain": "test",

    "status": "success",

    "reference": "48rx32f1womvcr4",

    "amount": 10000,

    "message": "madePayment",

    "gateway_response": "Payment successful",

    "paid_at": "2018-12-05T15:58:45.000Z",

    "created_at": "2018-12-05T15:58:02.000Z",

    "channel": "qr",

    "currency": "NGN",

    "ip_address": "18.130.45.28, 141.101.107.157",

    "metadata": "",

    "log": null,

    "fees": null,

    "fees_split": null,

    "authorization": {

      "authorization_code": "AUTH_2b4zs69fgy7qflh",

      "bin": "483953",

      "last4": "6208",

      "exp_month": "12",

      "exp_year": "2018",

      "channel": "qr",

      "card_type": "DEBIT",

      "bank": "Visa QR",

      "country_code": "NG",

      "brand": "VISA",

      "reusable": false,

      "signature": null,

      "account_name": "BoJack Horseman"

    },

    "customer": {

      "id": 16787,

      "first_name": "I",

      "last_name": "SURRENDER",

      "email": "customer@email.com",

      "customer_code": "CUS_ehg851zbxon0bvx",

      "phone": "",

      "metadata": null,

      "risk_action": "default"

    },

    "plan": {},

    "subaccount": {},

    "subaccount_group": {},

    "paidAt": "2018-12-05T15:58:45.000Z"

  }

}

QR code recurring charge

Charging returning customers directly is currently not available. You need to call the endpoint to start a new transaction.
Supported Apps

In order to complete a payment, your customers can scan or enter the code in a supported application. Here are the supported applications by providers:
Visa

Customers can scan Visa QR codes from the following banking apps:

    Ecobank
    First Bank
    Fidelity Bank
    Access Bank
    Access (Diamond) Bank
    Zenith Bank

SnapScan

Customers can complete a payment in a snap by scanning the QR code with their SnapScan iOS or Android app.
Scan to Pay

Customers can use Scan to Pay (formerly Masterpass) QR codes from any of the mobile apps listed below:
Banking Apps	Wallets	Standalone Scan to Pay
Standard Bank	Ukheshe	Nedbank Scan to Pay
FNB Banking	Spot (by Virgin Money)	Standard Bank Scan to Pay
Nedbank Money	Vodapay	Absa Scan to Pay
Capitec Bank	Telkom Pay	
Absa	Instapay	
RMB	Nedbank Avo       ,  Verify Payments
In a nutshell

The Verify Transaction API allows you confirm the status of a customer's transaction.
Transaction statuses

Webhooks are the preferred option for confirming a transaction status, but we currently send webhook events for just successful transactions. However, a transaction can have the following statuses:
Status	Meaning
abandoned	The customer has not completed the transaction.
failed	The transaction failed. For more information on why, refer to the message/gateway response.
ongoing	The customer is currently trying to carry out an action to complete the transaction. This can get returned when we're waiting on the customer to enter an otp or to make a transfer (for a pay with transfer transaction).
pending	The transaction is currently in progress.
processing	Same as pending, but for direct debit transactions.
queued	The transaction has been queued to be processed later. Only possible on bulk charge transactions.
reversed	The transaction was reversed. This could mean the transaction was refunded, or a chargeback was successfully logged for this transaction.
success	The transaction was successfully processed.
Verify a transaction

You do this by making a GET request to the Verify TransactionAPI endpoint from your server using your transaction reference. This is dependent on the method you used to initialize the transaction.
From Popup or Mobile SDKs

You'll have to send the reference to your server, then from your server you call the verify endpoint.
From the Redirect API

You initiate this request from your callback URL. The transaction reference is returned as a query parameter to your callback URL.
Helpful Tip

If you offer digital value like airtime, wallet top-up, digital credit, etc, always confirm that you have not already delivered value for that transaction to avoid double fulfillments, especially, if you also use webhooks.

Here's a code sample for verifying transactions:
Show Response

#!/bin/sh

curl https://api.paystack.co/transaction/verify/:reference

-H "Authorization: Bearer YOUR_SECRET_KEY"

-X GET

Warning

The API response has a status key response.status indicating the status of the API call. This is not the status of the transaction. The status of the transaction is in the data object in the verify API response, i.e response.data.status. Learn more about Paystack API format.
Charge returning Users

The verify response also returns information about the payment instrument that the user paid with in the data.authorization object. If the channel is card, then you can store the authorization_code for that card against that user, and use that charge the user for subsequent transaction. Learn more about recurring charges.   Charges,Accept Payments
In a nutshell

To accept a payment, create a transaction using our API, our client Javascript library, Popup JS, or our SDKs. Every transaction includes a link that can be used to complete payment.
Popup

Paystack Popup is a Javascript library that allow developers to build a secure and convenient payment flow for their web applications. You can add it to your frontend application via CDN, NPM or Yarn:

    CDNNPMYarn

<script src="https://js.paystack.co/v2/inline.js">

If you used NPM or Yarn, ensure you import the library as shown below:

import PaystackPop from '@paystack/inline-js'

With the library successfully installed, you can now begin the three-step integration process:

    Initialize transaction
    Complete transaction
    Verify transaction status

Initialize transaction

To get started, you need to initialize the transaction from your backend. Initializing the transaction from the backend ensures you have full control of the transaction details. To do this, make a POST request from your backend to the Initialize TransactionAPI endpoint:
Show Response

curl https://api.paystack.co/transaction/initialize

-H "Authorization: Bearer YOUR_SECRET_KEY"

-H "Content-Type: application/json"

-d '{ "email": "customer@email.com", 

      "amount": "500000"

    }'

-X POST

The data object of the response contains an access_code parameter that is needed to complete the transaction. You should store this parameter and send it to your frontend.
Do not use your secret key in your frontend

Never call the Paystack API directly from your frontend to avoid exposing your secret key on the frontend. All requests to the Paystack API should be initiated from your server, and your frontend gets the response from your server.
Complete transaction

Your frontend application should make a request to your backend to initialize the transaction and get the access_code as described in the previous section. On getting the access_code from your backend, you can then use Popup to complete the transaction:

const popup = new PaystackPop()

popup.resumeTransaction(access_code)

The resumeTransaction method triggers the checkout in the browser, allowing the user to choose their preferred payment channel to complete the transaction. You can check out the InlineJS reference guide to learn about the features available in Popup V2.
Verify transaction status

Finally, you need to confirm the status of the transaction by using either webhooks or the verify transactions endpoint. Regardless of the method used, you need to use the following parameter to confirm if you should deliver value to your customer or not:
Parameter	Description
data.status	This inidicates if the payment is successful or not
data.amount	This indicates the price of your product or service in the lower denomination of your currency.
Verify amount

When verifying the status of a transaction, you should also verify the amount to ensure it matches the value of the service you are delivering. If the amount doesn't match, do not deliver value to the customer.
Redirect

Here, you call the Initialize TransactionAPI from your server to generate a checkout link, then redirect your users to the link so they can pay. After payment is made, the users are returned to your website at the callback_url
Warning

Confirm that your server can conclude a TLSv1.2 connection to Paystack's servers. Most up-to-date software have this capability. Contact your service provider for guidance if you have any SSL errors.
Collect customer information

To initialize the transaction, you'll need to pass information such as email, first name, last name amount, transaction reference, etc. Email and amount are required. You can also pass any other additional information in the metadata object field.

The customer information can be retrieved from your database, session or cookie if you already have it stored, or from a form like in the example below.

    HTML

<form action="/save-order-and-pay" method="POST"> 

  <input type="hidden" name="user_email" value="<?php echo $email; ?>"> 

  <input type="hidden" name="amount" value="<?php echo $amount; ?>"> 

  <input type="hidden" name="cartid" value="<?php echo $cartid; ?>"> 

  <button type="submit" name="pay_now" id="pay-now" title="Pay now">Pay now</button>

</form>

Initialize transaction

When a customer clicks the payment action button, initialize a transaction by making a POST request to our API. Pass the email, amount and any other parameters to the Initialize TransactionAPI endpoint.

If the API call is successful, we will return an authorization URL which you will redirect to for the customer to input their payment information to complete the transaction.

Important notes

    The amount should be in the subunit of the supported currency.
    We used the cart_id from the form above as our transaction reference. You should use a unique transaction identifier from your system as your reference.
    We set the callback_url in the transaction_data array. If you don't do this, we'll use the one that is set on your dashboard. Setting it in the code allows you to be flexible with the redirect URL if you need to
    If you don't set a callback URL on the dashboard or on the code, the users will not be redirected back to your site after payment.
    You can set test callback URLs for test transactions and live callback URLs for live transactions.

    PHP

<?php

  $url = "https://api.paystack.co/transaction/initialize";


  $fields = [

    'email' => "customer@email.com",

    'amount' => "20000",

    'callback_url' => "https://hello.pstk.xyz/callback",

    'metadata' => ["cancel_action" => "https://your-cancel-url.com"]

  ];


  $fields_string = http_build_query($fields);


  //open connection

  $ch = curl_init();

  

  //set the url, number of POST vars, POST data

  curl_setopt($ch,CURLOPT_URL, $url);

  curl_setopt($ch,CURLOPT_POST, true);

  curl_setopt($ch,CURLOPT_POSTFIELDS, $fields_string);

  curl_setopt($ch, CURLOPT_HTTPHEADER, array(

    "Authorization: Bearer SECRET_KEY",

    "Cache-Control: no-cache",

  ));

  

  //So that curl_exec returns the contents of the cURL; rather than echoing it

  curl_setopt($ch,CURLOPT_RETURNTRANSFER, true); 

  

  //execute post

  $result = curl_exec($ch);

  echo $result;

?>

Verify Transaction

If the transaction is successful, Paystack will redirect the user back to a callback_url you set. We'll append the transaction reference in the URL. In the example above, the user will be redirected to http://your_website.com/postpayment_callback.php?reference=YOUR_REFERENCE.

So you retrieve the reference from the URL parameter and use that to call the verify endpoint to confirm the status of the transaction. Learn more about verifying transactions.

It's very important that you call the Verify endpoint to confirm the status of the transactions before delivering value. Just because the callback_url was visited doesn't prove that transaction was successful.
Handle Webhook

When a payment is successful, Paystack sends a charge.success webhook event to webhook URL that you provide. Learn more about using webhooks.
Mobile SDKs

With our mobile SDKs, we provide a collection of methods and interfaces tailored to the aesthetic of the platform. Transactions are initiated on the server and completed in the SDK. The SDK requires an access_code to display the UI component that accepts payment.

To get the access_code, you need to initialize a transaction by making a POST request on your server to the Initialize TransactionAPI endpoint:
Show Response

curl https://api.paystack.co/transaction/initialize

-H "Authorization: Bearer YOUR_SECRET_KEY"

-H "Content-Type: application/json"

-d '{ "email": "customer@email.com", 

      "amount": "500000"

    }'

-X POST

On a successful initialization of the transaction, you get a response that contains an access_code. You need to return this access_code back to your mobile app.
Secret key safeguarding

Do not make an API request to the Initialize Transaction endpoint directly on your mobile app because it requires your secret key. Your secret key should only be used on your server where stronger security measures can be put in place.

With the access_code in place, you can now use the SDKs to complete the transaction.
Android SDK

You need to install the SDK by adding the paystack-ui dependency to the dependencies block of your app-level build.gradle file:
Latest dependency version

You should check Maven Central to get the latest version before installation.

    build.gradle

dependencies {

  implementation 'com.paystack.android:paystack-ui:0.0.9'

}

With all the requirements for accepting payment now in place, you can initialize and use the SDK as shown below:

    KotlinJava

// other imports


import com.paystack.android.core.Paystack

import com.paystack.android.ui.paymentsheet.PaymentSheet

import com.paystack.android.ui.paymentsheet.PaymentSheetResult


class MainActivity : AppCompatActivity() {

    private lateinit var paymentSheet: PaymentSheet


    override fun onCreate(savedInstanceState: Bundle?) {

        super.onCreate(savedInstanceState)

        // Other code snippets


        Paystack.builder()

            .setPublicKey("pk_test_xxxx")

            .build()

        paymentSheet = PaymentSheet(this, ::paymentComplete)


    }


    private fun makePayment() {

        // Pass access_code from transaction initialize call

        paymentSheet.launch("br6cgmvflhn3qtd")

    }



    private fun paymentComplete(paymentSheetResult: PaymentSheetResult) {

        val message = when (paymentSheetResult) {

            PaymentSheetResult.Cancelled -> "Cancelled"

            is PaymentSheetResult.Failed -> {

                Log.e("Something went wrong", paymentSheetResult.error.message.orEmpty(), paymentSheetResult.error)

                paymentSheetResult.error.message ?: "Failed"

            }


            is PaymentSheetResult.Completed -> {

                // Returns the transaction reference  PaymentCompletionDetails(reference={TransactionRef})

                Log.d("Payment successful", paymentSheetResult.paymentCompletionDetails.toString())

                "Successful"

            }

        }

    }

}

You can check out the Android SDK reference to learn more about the methods and interfaces available for integration.
iOS SDK

The installation of the SDK can be done via the Swift Package Manager. To add the required packages, ensure you have the latest version of XCode installed and follow these steps:

    Select File > Add Package Dependencies…
    Copy the repo URL and paste it in the search box of the package dependency popup

You can read the Swift Package Manager documentation to learn more about adding packages to your project.

With all the requirements for accepting payment now in place, you can initialize and use the SDK:

    SwiftUIUIKit

import SwiftUI

import PaystackCore

import PaystackUI


struct PaymentView: View {

	let paystack = try? PaystackBuilder

			.newInstance

			.setKey("pk_domain_xxxxxxxx")

			.build()


	var body: some View {

		VStack(spacing: 8) {

			Text("Make Payemnt")


			paystack?.chargeUIButton(accessCode: "0peioxfhpn", onComplete: paymentDone) {

				Text("Initiate Payment")

			}

		}

		.padding()

	}


	func paymentDone(_ result: TransactionResult) {

		// Handle transaction result

		print(result)

	}

}


// ....

You can check out the iOS SDK reference to learn more about the methods and interfaces available for integration.
Charge API

The Create ChargeAPI endpoint allows you to pass details of any payment channel directly to Paystack, along with the transaction details (email, amount, etc). We provide a couple of payment channels that you can harness based on your use case.
Use cases

The Charge API exposes the core components powering our checkout. Developers can use these component to develop solutions that will cater to their customers specific needs. Some of these needs include:

    Serving non-smartphone users. Some of your users might be using mobile phones that can't access the internet. With the charge API, you can initiate a payment request form your server and send a prompt for payment completion via phone numbers to these users.
    Harnessing mobile OS APIs for a better user experience. Some businesses offer their products via mobile apps (Android and iOS). Mobile operating systems provide a rich set of APIs that developers can take advantage of. One of such APIs allow developers to autofill an OTP in a form. There are also APIs for dialing codes. Developers can combine the charge API with the mobile OS APIs to provide a richer experience to their users. 

Here is a sample payload to the Charge API containing transaction details and an object for a payment instrument - in this case Mobile money:

    JSON

{

  "amount": 1000,

  "email": "customer@email.com",

  "currency": "GHS",

  "mobile_money": {

    "phone": "0553241149",

    "provider": "MTN"

  }

}

Handling Charge API responses

When you call the Create ChargeAPI endpoint, the response contains a data.status which tells you what the next step in the process. Depending on the value in the data.status, you may need to prompt the user for an input as indicated in the response message (like OTP or pin or date of birth), or display an action that the user needs to complete on their device - like scanning a QR code or dialling a USSD code or redirecting to a 3DSecure page. So you follow the prompt on the data.status until there is no more user input required, then you listen for events via webhooks.

For the steps that prompt for user input, you will be required to display a form to the user to collect the requested input and send it to the relevant endpoint as shown in the table below. For the steps that require the user to complete an action on their device, we recommend that you display a button for the user to confirm the payment after they have performed that action so that you can listen for events via webhooks.

Below is the list of responses you can receive from the Create ChargeAPI endpoint and what you should do next:
Value	Description
pending	Transaction is being processed. Call Check pending charge at least 10seconds after getting this status to check status
timeout	Transaction has failed. You may start a new charge after showing data.message to user
success	Transaction is successful. You can now provide value
send_birthday	Customer's birthday is needed to complete the transaction. Show data.display_text to user with an input that accepts the birthdate and submit to the Submit BirthdayAPI endpoint with reference and birthday
send_otp	Paystack needs OTP from customer to complete the transaction. Show data.display_text to user with an input that accepts OTP and submit the OTP to the Submit OTPAPI endpoint with reference and otp
failed	Transaction failed. No remedy for this, start a new charge after showing data.message to user
Handle Webhook

When a payment is successful, Paystack sends a charge.success webhook event to webhook URL that you provide. It is highly recommended that you use webhooks to confirm the payment status before delivering value to your customers.
The Charge API allows you to configure payment channel of your choice when initiating a payment.
Create Charge

Initiate a payment by integrating the payment channel of your choice.
Headers
authorization
String
	Set value to Bearer SECRET_KEY
content-type
String
	Set value to application/json
Body Parameters
email
String
	Customer's email address
amount
String
	Amount in subunit of the supported currency
split_code
String
	
The split code of a previously created split. e.g. SPL_98WF13Eb3w
subaccount
String
	
The code for the subaccount that owns the payment. e.g. ACCT_8f4s1eq7ml6rlzj
transaction_charge
Integer
	
An amount used to override the split configuration for a single split payment. If set, the amount specified goes to the main account regardless of the split configuration.
bearer
String
	
Use this param to indicate who bears the transaction charges. Allowed values are: account or subaccount (defaults to account).
bank
Object
	
Bank account to charge (don't send if charging an authorization code)
bank_transfer
Object
	
Takes the settings for the Pay with Transfer (PwT) channel. Pass in the account_expires_at param to set the expiry time.
ussd
Object
	
USSD type to charge (don't send if charging an authorization code, bank or card)
mobile_money
Object
	
Mobile details (don't send if charging an authorization code, bank or card)
qr
Object
	
Takes a provider object with the either of the following values: scan-to-pay, visa
authorization_code
String
	
An authorization code to charge (don't send if charging a bank account)
pin
String
	
4-digit PIN (send with a non-reusable authorization code)
metadata
Object
	
Used for passing additional details for your post-payment processes
reference
String
	
Unique transaction reference. Only -, .`, = and alphanumeric characters allowed.
device_id
String
	
This is the unique identifier of the device a user uses in making payment. Only -, .`, = and alphanumeric characters allowed.
Show optional parameters
POST/charge
cURL

#!/bin/sh

url="https://api.paystack.co/charge"

authorization="Authorization: Bearer YOUR_SECRET_KEY"

content_type="Content-Type: application/json"

data='{ 

  "email": "customer@email.com",

  "amount": "10000",

  "metadata": {

    "custom_fields": [

      {

        "value": "makurdi",

        "display_name": "Donation for",

        "variable_name": "donation_for"

      }

    ]

  },

  "bank": {

      code: "057",

      account_number: "0000000000"

  },

  "birthday": "1995-12-23"

}'


curl "$url" -H "$authorization" -H "$content_type" -d "$data" -X POST

Sample Response
200 Ok

{

  "status": true,

  "message": "Charge attempted",

  "data": {

    "amount": 200,

    "currency": "NGN",

    "transaction_date": "2017-05-24T05:56:12.000Z",

    "status": "success",

    "reference": "zuvbpizfcf2fs7y",

    "domain": "test",

    "metadata": {

      "custom_fields": [

        {

          "display_name": "Merchant name",

          "variable_name": "merchant_name",

          "value": "Van Damme"

        },

        {

          "display_name": "Paid Via",

          "variable_name": "paid_via",

          "value": "API call"

        }

      ]

    },

    "gateway_response": "Successful",

    "message": null,

    "channel": "card",

    "ip_address": "54.154.89.28, 162.158.38.82, 172.31.38.35",

    "log": null,

    "fees": 3,

    "authorization": {

      "authorization_code": "AUTH_6tmt288t0o",

      "bin": "408408",

      "last4": "4081",

      "exp_month": "12",

      "exp_year": "2020",

      "channel": "card",

      "card_type": "visa visa",

      "bank": "TEST BANK",

      "country_code": "NG",

      "brand": "visa",

      "reusable": true,

      "signature": "SIG_uSYN4fv1adlAuoij8QXh",

      "account_name": "BoJack Horseman"

    },

    "customer": {

      "id": 14571,

      "first_name": null,

      "last_name": null,

      "email": "test@email.co",

      "customer_code": "CUS_hns72vhhtos0f0k",

      "phone": null,

      "metadata": null,

      "risk_action": "default"

    },

    "plan": null

  }

}

Submit PIN

Submit PIN to continue a charge
Headers
authorization
String
	Set value to Bearer SECRET_KEY
content-type
String
	Set value to application/json
Body Parameters
pin
String
	PIN submitted by user
reference
String
	Reference for transaction that requested pin
POST/charge/submit_pin
cURL

#!/bin/sh

url="https://api.paystack.co/charge/submit_pin"

authorization="Authorization: Bearer YOUR_SECRET_KEY"

content_type="Content-Type: application/json"

data='{ 

  "pin": "1234", 

  "reference": "5bwib5v6anhe9xa"

}'


curl "$url" -H "$authorization" -H "$content_type" -d "$data" -X POST

Sample Response
200 Ok

{

  "status": true,

  "message": "Charge attempted",

  "data": {

    "id": 2046671778,

    "domain": "test",

    "status": "success",

    "reference": "36xz3b9rie9ppvz",

    "amount": 10000,

    "message": "madePayment",

    "gateway_response": "Approved",

    "paid_at": "2022-08-24T12:00:18.000Z",

    "created_at": "2022-08-24T11:58:41.000Z",

    "channel": "bank",

    "currency": "NGN",

    "ip_address": "172.31.68.204",

    "metadata": "",

    "log": null,

    "fees": 50,

    "fees_split": null,

    "authorization": {

      "authorization_code": "AUTH_nrp5ly1goc",

      "bin": "000XXX",

      "last4": "X000",

      "exp_month": "12",

      "exp_year": "9999",

      "channel": "bank",

      "card_type": "",

      "bank": "Zenith Bank",

      "country_code": "NG",

      "brand": "Zenith Emandate",

      "reusable": false,

      "signature": null,

      "account_name": null

    },

    "customer": {

      "id": 44494174,

      "first_name": null,

      "last_name": null,

      "email": "charge@email.com",

      "customer_code": "CUS_cm4hqzmhg0u0ded",

      "phone": null,

      "metadata": null,

      "risk_action": "default",

      "international_format_phone": null

    },

    "plan": null,

    "split": {},

    "order_id": null,

    "paidAt": "2022-08-24T12:00:18.000Z",

    "createdAt": "2022-08-24T11:58:41.000Z",

    "requested_amount": 10000,

    "pos_transaction_data": null,

    "source": null,

    "fees_breakdown": null,

    "transaction_date": "2022-08-24T11:58:41.000Z",

    "plan_object": {},

    "subaccount": {}

  }

}

##### SUBSCRIPTION ####


During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26/venv/lib/python3.11/site-packages/uvicorn/protocols/http/h11_impl.py", line 406, in run_asgi
    result = await app(  # type: ignore[func-returns-value]
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26/venv/lib/python3.11/site-packages/uvicorn/middleware/proxy_headers.py", line 70, in __call__
    return await self.app(scope, receive, send)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26/venv/lib/python3.11/site-packages/fastapi/applications.py", line 1054, in __call__
    await super().__call__(scope, receive, send)
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26/venv/lib/python3.11/site-packages/starlette/applications.py", line 113, in __call__
    await self.middleware_stack(scope, receive, send)
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26/venv/lib/python3.11/site-packages/starlette/middleware/errors.py", line 187, in __call__
    raise exc
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26/venv/lib/python3.11/site-packages/starlette/middleware/errors.py", line 165, in __call__
    await self.app(scope, receive, _send)
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26/venv/lib/python3.11/site-packages/starlette/middleware/base.py", line 185, in __call__
    with collapse_excgroups():
  File "/usr/lib/python3.11/contextlib.py", line 155, in __exit__
    self.gen.throw(typ, value, traceback)
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26/venv/lib/python3.11/site-packages/starlette/_utils.py", line 83, in collapse_excgroups
    raise exc
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26/venv/lib/python3.11/site-packages/starlette/middleware/base.py", line 187, in __call__
    response = await self.dispatch_func(request, call_next)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26fullperfect/Visiszipnov26/app/main.py", line 510, in log_requests
    response = await call_next(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26/venv/lib/python3.11/site-packages/starlette/middleware/base.py", line 163, in call_next
    raise app_exc
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26/venv/lib/python3.11/site-packages/starlette/middleware/base.py", line 149, in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26/venv/lib/python3.11/site-packages/starlette/middleware/base.py", line 185, in __call__
    with collapse_excgroups():
  File "/usr/lib/python3.11/contextlib.py", line 155, in __exit__
    self.gen.throw(typ, value, traceback)
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26/venv/lib/python3.11/site-packages/starlette/_utils.py", line 83, in collapse_excgroups
    raise exc
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26/venv/lib/python3.11/site-packages/starlette/middleware/base.py", line 187, in __call__
    response = await self.dispatch_func(request, call_next)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26fullperfect/Visiszipnov26/app/middleware/ip_whitelist.py", line 79, in validate_ip
    return await call_next(request)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26/venv/lib/python3.11/site-packages/starlette/middleware/base.py", line 163, in call_next
    raise app_exc
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26/venv/lib/python3.11/site-packages/starlette/middleware/base.py", line 149, in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26/venv/lib/python3.11/site-packages/starlette/middleware/cors.py", line 85, in __call__
    await self.app(scope, receive, send)
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26/venv/lib/python3.11/site-packages/starlette/middleware/exceptions.py", line 62, in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26/venv/lib/python3.11/site-packages/starlette/_exception_handler.py", line 62, in wrapped_app
    raise exc
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26/venv/lib/python3.11/site-packages/starlette/_exception_handler.py", line 51, in wrapped_app
    await app(scope, receive, sender)
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26/venv/lib/python3.11/site-packages/starlette/routing.py", line 715, in __call__
    await self.middleware_stack(scope, receive, send)
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26/venv/lib/python3.11/site-packages/starlette/routing.py", line 735, in app
    await route.handle(scope, receive, send)
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26/venv/lib/python3.11/site-packages/starlette/routing.py", line 288, in handle
    await self.app(scope, receive, send)
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26/venv/lib/python3.11/site-packages/starlette/routing.py", line 76, in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26/venv/lib/python3.11/site-packages/starlette/_exception_handler.py", line 62, in wrapped_app
    raise exc
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26/venv/lib/python3.11/site-packages/starlette/_exception_handler.py", line 51, in wrapped_app
    await app(scope, receive, sender)
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26/venv/lib/python3.11/site-packages/starlette/routing.py", line 73, in app
    response = await f(request)
               ^^^^^^^^^^^^^^^^
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26/venv/lib/python3.11/site-packages/fastapi/routing.py", line 297, in app
    raw_response = await run_endpoint_function(
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26/venv/lib/python3.11/site-packages/fastapi/routing.py", line 210, in run_endpoint_function
    return await dependant.call(**values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/adesoji/Documents/Visis_revisions/Visiszipnov26fullperfect/Visiszipnov26/app/api/endpoints/payment_callback.py", line 42, in paystack_callback
    subscription_data = await create_subscription_on_paystack(
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: create_subscription_on_paystack() got an unexpected keyword argument 'customer', also when i am trying to pay via card, i didn't see wheer to input my card details in {
  "authorization_url": "https://checkout.paystack.com/f4memgp79cvbepe",
  "access_code": "f4memgp79cvbepe",
  "reference": "sub_1734723111"
}, you are still missing out some things, also can we know wah the server at paystack expects, now i have a transaction.py that works well, just take clue from there, don't consfuse it with subscription,  ijust expect you to give me the code that will make everything work, now in the form selection, i want their values to be there exactly, where i select from a drop down that selects either ussd or any other value.  tips from transaction.py and transaction_public.py  # app/api/endpoints/user/transactions.py

from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks, Request
from sqlalchemy.orm import Session
from typing import List
import logging

from app.models.transaction import Transaction
from app.schemas.transaction import (
    TransactionInitializeRequest,
    TransactionInitializeResponse,
    TransactionResponse,
    ChargeAuthorizationRequest,
    PartialDebitRequest,
)
from app.services.transaction_service import (
    initialize_transaction,
    verify_transaction,
    list_transactions,
    fetch_transaction_by_reference,
    fetch_transaction,
    charge_authorization,
    view_transaction_timeline,
    get_transaction_totals,
    export_transactions,
    partial_debit,
    handle_transaction_webhook,
)
from app.api.endpoints.user.auth import get_current_user
from app.database import get_db
from app.models.user import User
from app.utils.paystack_utils import verify_paystack_signature, verify_paystack_transaction
from fastapi.responses import Response
from app.utils.email_utils import send_email  # Ensure this utility exists

logger = logging.getLogger(__name__)

router = APIRouter(
    prefix="/transactions",
    tags=["Transactions"],
)

@router.post("/initialize", response_model=TransactionInitializeResponse)
async def initialize_transaction_endpoint(
    transaction_request: TransactionInitializeRequest,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    Initialize a transaction.
    """
    try:
        initialization_response = await initialize_transaction(
            transaction_request=transaction_request,
            db=db,
            current_user=current_user
        )
        return initialization_response
    except Exception as e:
        logger.error(f"Transaction initialization failed: {e}")
        raise HTTPException(status_code=400, detail=str(e))

@router.get("/verify/{reference}", response_model=TransactionResponse)
async def verify_transaction_endpoint(
    reference: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    Verify a transaction using its reference.
    """
    try:
        transaction = await verify_transaction(reference=reference, db=db)
        if not transaction or transaction.user_id != current_user.id:
            raise HTTPException(status_code=404, detail="Transaction not found")
        return transaction
    except Exception as e:
        logger.error(f"Transaction verification failed: {e}")
        raise HTTPException(status_code=400, detail=str(e))
    
@router.get("/totals")
async def get_transaction_totals_endpoint(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    Get total amount received in transactions for the current user.
    """
    try:
        totals = await get_transaction_totals(db=db, user_id=current_user.id)
        return totals
    except Exception as e:
        logger.error(f"Failed to retrieve transaction totals: {e}")
        raise HTTPException(status_code=400, detail=str(e))

@router.get("/timeline/{id_or_reference}")
async def view_transaction_timeline_endpoint(
    id_or_reference: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    timeline = await view_transaction_timeline(id_or_reference=id_or_reference)
    if not timeline:
        # If there's no timeline data, return a 404 or an appropriate message
        raise HTTPException(status_code=404, detail="No timeline data found for this transaction.")
    return timeline


@router.get("/export")
async def export_transactions_endpoint(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    Export transactions for the current user.
    """
    try:
        export_link = await export_transactions(db=db, user_id=current_user.id)
        return {"export_link": export_link}
    except Exception as e:
        logger.error(f"Failed to export transactions: {e}")
        raise HTTPException(status_code=400, detail=str(e))

# @router.get("/timeline/{id_or_reference}")
# async def view_transaction_timeline_endpoint(
#     id_or_reference: str,
#     db: Session = Depends(get_db),
#     current_user: User = Depends(get_current_user),
# ):
#     """
#     View the timeline of a transaction.
#     """
#     try:
#         timeline = await view_transaction_timeline(id_or_reference=id_or_reference)
#         return timeline
#     except Exception as e:
#         logger.error(f"Failed to retrieve transaction timeline: {e}")
#         raise HTTPException(status_code=400, detail=str(e))

@router.get("/", response_model=List[TransactionResponse])
async def list_transactions_endpoint(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    List all transactions for the current user.
    """
    transactions = list_transactions(db=db, user_id=current_user.id)
    return transactions


@router.get("/{transaction_id}", response_model=TransactionResponse)
async def fetch_transaction_endpoint(
    transaction_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    Retrieve a specific transaction by ID.
    """
    transaction = fetch_transaction(db=db, transaction_id=transaction_id)
    if not transaction or transaction.user_id != current_user.id:
        raise HTTPException(status_code=404, detail="Transaction not found")
    return transaction

@router.post("/charge_authorization", response_model=TransactionResponse)
async def charge_authorization_endpoint(
    charge_request: ChargeAuthorizationRequest,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    Charge a customer’s authorization. you cannot reuse a reference that was already used in a previous successful transaction.
    Regarding the use of references:

    Does Paystack generate references?
    If you do not provide a reference field, Paystack will generate one for you automatically. This is helpful if you don't want to manage references yourself. Paystack will return the generated reference in the API response.

    What if I need a known reference?
   If you want a known, trackable reference, you must generate it yourself each time you create or charge a transaction. Each new charge attempt must have a unique reference. If you reuse a reference that was previously associated with a successful transaction, Paystack will return a "Duplicate Transaction Reference" error.

   How do clients handle references for charge_authorization?
   For ease of use, you have two options:

   Let Paystack generate the reference: Omit the reference field entirely. Paystack will respond with the generated reference in its response. You can store and use it later if needed.
   Generate your own unique reference each time you call charge_authorization. This can be a random string. It just needs to be unique so Paystack doesn’t consider it a duplicate.
   In summary:

   Remove the comment from your JSON request.
   Either omit the reference field and let Paystack create it for you or ensure you generate a unique reference each time you call charge_authorization.
    """
    try:
        transaction = await charge_authorization(
            charge_request=charge_request,
            db=db,
            current_user=current_user
        )
        return transaction
    except Exception as e:
        logger.error(f"Charge authorization failed: {e}")
        raise HTTPException(status_code=400, detail=str(e))
    
# @router.get("/timeline/{id_or_reference}")
# async def view_transaction_timeline_endpoint(
#     id_or_reference: str,
#     db: Session = Depends(get_db),
#     current_user: User = Depends(get_current_user),
# ):
#     """
#     View the timeline of a transaction.
#     """
#     try:
#         timeline = await view_transaction_timeline(id_or_reference=id_or_reference)
#         return timeline
#     except Exception as e:
#         logger.error(f"Failed to retrieve transaction timeline: {e}")
#         raise HTTPException(status_code=400, detail=str(e))




# @router.get("/totals")
# async def get_transaction_totals_endpoint(
#     db: Session = Depends(get_db),
#     current_user: User = Depends(get_current_user),
# ):
#     """
#     Get total amount received in transactions for the current user.
#     """
#     try:
#         totals = await get_transaction_totals(db=db, user_id=current_user.id)
#         return totals
#     except Exception as e:
#         logger.error(f"Failed to retrieve transaction totals: {e}")
#         raise HTTPException(status_code=400, detail=str(e))




@router.post("/partial_debit", response_model=TransactionResponse)
async def partial_debit_endpoint(
    partial_debit_request: PartialDebitRequest,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    Perform a partial debit on a customer's account.
    """
    try:
        transaction = await partial_debit(
            partial_debit_request=partial_debit_request,
            db=db,
            current_user=current_user
        )
        return transaction
    except Exception as e:
        logger.error(f"Partial debit failed: {e}")
        raise HTTPException(status_code=400, detail=str(e))

@router.post("/webhook")
async def paystack_webhook(
    request: Request,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db),
):
    """
    Handle Paystack webhook events for transactions.
    """
    is_valid = await verify_paystack_signature(request)
    if not is_valid:
        logger.warning("Unauthorized webhook attempt.")
        return Response(status_code=401)

    payload = await request.json()
    event = payload.get('event')
    data = payload.get('data')

    if event == 'charge.success':
        reference = data.get('reference')
        logger.info(f"Payment successful for reference {reference}")

        success = await handle_transaction_webhook(db=db, reference=reference)
        if success:
            # Send thank-you email in background
            transaction = fetch_transaction_by_reference(db=db, reference=reference)
            if transaction:
                email = transaction.customer_email
                amount = transaction.amount
                subject = "Thank you for your transaction"
                body = f"""
                <p>Dear {email},</p>
                <p>Thank you for your payment of NGN {amount:.2f}.</p>
                <p>Your support helps us continue our mission.</p>
                <p>Best regards,<br>Your Team</p>
                """
                background_tasks.add_task(send_email, subject, email, body)
        else:
            logger.error(f"Failed to handle webhook for reference {reference}")
    else:
        logger.info(f"Unhandled event type: {event}")

    return Response(status_code=200), # app/api/endpoints/transactions_public.py

from fastapi import APIRouter, HTTPException, Request, Depends, BackgroundTasks
from sqlalchemy.orm import Session
from fastapi.responses import Response
import logging

from app.database import get_db
from app.utils.paystack_utils import verify_paystack_transaction, verify_paystack_signature
from app.services.transaction_service import fetch_transaction_by_reference
from app.utils.email_utils import send_email

logger = logging.getLogger(__name__)

public_router = APIRouter(prefix="/transactions", tags=["Transactions-Public"])

@public_router.get("/callback")
async def paystack_callback(
    request: Request,
    db: Session = Depends(get_db)
):
    """
    Handle Paystack callback after payment is completed.
    Public route: No get_current_user dependency.
    """
    reference = request.query_params.get('reference')
    if not reference:
        logger.error("Reference not found in callback.")
        raise HTTPException(status_code=400, detail="Reference not found in callback.")

    # Verify the transaction with Paystack
    transaction_data = await verify_paystack_transaction(reference)
    if transaction_data:
        transaction = fetch_transaction_by_reference(db=db, reference=reference)
        if transaction:
            # Update transaction fields
            transaction.status = transaction_data.get('status')
            transaction.paid_at = transaction_data.get('paid_at')
            transaction.channel = transaction_data.get('channel')
            transaction.transaction_id = transaction_data.get('id')
            transaction.customer_id = transaction_data['customer']['id']
            transaction.authorization_code = transaction_data['authorization']['authorization_code']
            transaction.currency = transaction_data.get('currency')
            transaction.transaction_metadata = transaction_data.get('metadata')
            db.commit()
            return {"message": "Payment successful"}
        else:
            logger.error(f"Transaction with reference {reference} not found in database.")
            raise HTTPException(status_code=404, detail="Transaction not found.")
    else:
        logger.error("Payment verification failed.")
        raise HTTPException(status_code=400, detail="Payment verification failed.")
 take tips from here with the information below to ensure the subscription works well , also allow for when a user wants to pay subscription via bank transfer.   i am using Nigeria.   Single Transfers
In a nutshell

Send money to your customers by using the Transfer API

You can transfer money in four easy steps:

    Create a transfer recipient
    Generate a transfer reference
    Initiate a transfer
    Listen for transfer status

Before you begin!

To send money on Paystack, you need API keys to authenticate your transfers. You can find your keys on the Paystack Dashboard under Settings → API Keys & Webhooks.
Create a transfer recipient

A transfer recipient is a beneficiary on your integration that you can send money to. Before sending money to your customer, you need to collect their details first, then use their details to create a transfer recipient. We support different recipients in different countries:
Type	Description	Currency
ghipss	This means Ghana Interbank Payment and Settlement Systems. It represents bank account in Ghana.	GHS
mobile_money	Mobile Money or MoMo is an account tied to a mobile number.	GHS/KES
kepss	This is the Kenya Electronic Payment and Settlement System. It represents bank accounts in Kenya.	KES
nuban	This means the Nigerian Uniform Bank Account Number. It represents bank accounts in Nigeria.	NGN
basa	This means the Banking Association South Africa. It represents bank accounts in South Africa.	ZAR
authorization	This is a unique code that represents a customer’s card. We return an authorization code after a user makes a payment with their card.	All

The recipient_code from the data object is the unique identifier for a user and would be used to make transfers to that customer This code should be saved with the customer's records in your database.
Generate a transfer reference

A transfer reference is a unique identifier that lets you track, manage and reconcile each transfer request made on your integration. Transfer references allow you to prevent double crediting as you can retry a non-conclusive transfer rather than initiate a new request.

In order to take advantage of a transfer reference, you need to generate and provide it for every request. When you don’t provide a transfer reference, Paystack generates one for you but this defeats the purpose of the transfer reference.

We recommend generating a v4 UUID reference of no more than 100 characters. However, if you prefer implementing your own logic, you should ensure your reference contains at least 16 alphanumeric characters.

{

	"source": "balance",

	"reason": "Savings",

	"amount": 30000,

	"reference": "your-unique-reference",

	"recipient": "RCP_1a25w1h3n0xctjg"

}

Initiate a transfer

To send money to a customer, you make a POST request to the Initate TransferAPI, passing the reference and recipient_code previously created.
Disabling OTP

When building a fully automated system, you might need to disable OTP for transfers. You can disable OTP from the Preferences tab on the Paystack Dashoard. You should uncheck the Confirm transfers before sending checkbox as shown in the image below.
Image of the disabled OTP state of tranfers
Show Response

curl https://api.paystack.co/transfer

-H "Authorization: Bearer YOUR_SECRET_KEY"

-H "Content-Type: application/json"

-d '{ "source": "balance", 

      "amount": "37800",

      "reference": "your-unique-reference", 

      "recipient": "RCP_t0ya41mp35flk40", 

      "reason": "Holiday Flexing" 

    }'

-X POST


When you send this request, if there are no errors, the response comes back with a pending status, while the transfer is being processed.
Retrying a transfer

If there is an error with the transfer request, kindly retry the transaction with the same reference in order to avoid double crediting. If a new reference is used, the transfer would be treated as a new request.

Test transfers always return success, because there is no processing involved. The live transfers processing usually take between a few seconds and a few minutes. When it's done processing, a notification is sent to your webhook URL.
Verify a transfer

When a transfer is initiated, it could take a few seconds or minutes to be processed. This is why we recommend relying on webhooks for verification as opposed to polling.
Receiving Notifications

In order to receive notifications, you need to implement a webhook URL and set the webhook URL on your Paystack Dashboard.

Once a transfer is processed, we send the final status of the transfer as a POST request to your webhook URL.
Event	Description
transfer.success	This is sent when the transfer is successful
transfer.failed	This is sent when the transfer fails
transfer.reversed	This is sent when we refund a previously debited amount for a transfer that couldn’t be completed

    Transfer SuccessfulTransfer FailedTransfer Reversed

{

  "event": "transfer.success",

  "data": {

    "amount": 30000,

    "currency": "NGN",

    "domain": "test",

    "failures": null,

    "id": 37272792,

    "integration": {

      "id": 463433,

      "is_live": true,

      "business_name": "Boom Boom Industries NG"

    },

    "reason": "Have fun...",

    "reference": "1jhbs3ozmen0k7y5efmw",

    "source": "balance",

    "source_details": null,

    "status": "success",

    "titan_code": null,

    "transfer_code": "TRF_wpl1dem4967avzm",

    "transferred_at": null,

    "recipient": {

      "active": true,

      "currency": "NGN",

      "description": "",

      "domain": "test",

      "email": null,

      "id": 8690817,

      "integration": 463433,

      "metadata": null,

      "name": "Jack Sparrow",

      "recipient_code": "RCP_a8wkxiychzdzfgs",

      "type": "nuban",

      "is_deleted": false,

      "details": {

        "account_number": "0000000000",

        "account_name": null,

        "bank_code": "011",

        "bank_name": "First Bank of Nigeria"

      },

      "created_at": "2020-09-03T12:11:25.000Z",

      "updated_at": "2020-09-03T12:11:25.000Z"

    },

    "session": {

      "provider": null,

      "id": null

    },

    "created_at": "2020-10-26T12:28:57.000Z",

    "updated_at": "2020-10-26T12:28:57.000Z"

  },     SuccessfulTransfer FailedTransfer Reversed

{

  "event": "transfer.failed",

  "data": {

    "amount": 200000,

    "currency": "NGN",

    "domain": "test",

    "failures": null,

    "id": 69123462,

    "integration": {

      "id": 100043,

      "is_live": true,

      "business_name": "Paystack"

    },

    "reason": "Enjoy",

    "reference": "1976435206",

    "source": "balance",

    "source_details": null,

    "status": "failed",

    "titan_code": null,

    "transfer_code": "TRF_chs98y5rykjb47w",

    "transferred_at": null,

    "recipient": {

      "active": true,

      "currency": "NGN",

      "description": null,

      "domain": "test",

      "email": "test@email.com",

      "id": 13584206,

      "integration": 100043,

      "metadata": null,

      "name": "Ted Lasso",

      "recipient_code": "RCP_cjcua8itre45gs",

      "type": "nuban",

      "is_deleted": false,

      "details": {

        "authorization_code": null,

        "account_number": "0123456789",

        "account_name": "Ted Lasso",

        "bank_code": "011",

        "bank_name": "First Bank of Nigeria"

      },

      "created_at": "2021-04-12T15:30:14.000Z",

      "updated_at": "2021-04-12T15:30:14.000Z"

    },

    "session": {

      "provider": "nip",

      "id": "74849400998877667"

    },

    "created_at": "2021-04-12T15:30:15.000Z",

    "updated_at": "2021-04-12T15:41:21.000Z"

  }

}, {

  "event": "transfer.reversed",

  "data": {

    "amount": 10000,

    "currency": "NGN",

    "domain": "live",

    "failures": null,

    "id": 20615868,

    "integration": {

      "id": 100073,

      "is_live": true,

      "business_name": "Night's Watch Inc"

    },

    "reason": "test balance ledger elastic changes",

    "reference": "jvrjckwenm",

    "source": "balance",

    "source_details": null,

    "status": "reversed",

    "titan_code": null,

    "transfer_code": "TRF_js075pj9u07f34l",

    "transferred_at": "2020-03-24T07:14:00.000Z",

    "recipient": {

      "active": true,

      "currency": "NGN",

      "description": null,

      "domain": "live",

      "email": "jon@sn.ow",

      "id": 1476759,

      "integration": 100073,

      "metadata": null,

      "name": "JON SNOW",

      "recipient_code": "RCP_hmcj8ciho490bvi",

      "type": "nuban",

      "is_deleted": false,

      "details": {

        "authorization_code": null,

        "account_number": "0000000000",

        "account_name": null,

        "bank_code": "011",

        "bank_name": "First Bank of Nigeria"

      },

      "created_at": "2019-04-10T08:39:10.000Z",

      "updated_at": "2019-11-27T20:43:57.000Z"

    },

    "session": {

      "provider": "nip",

      "id": "110006200324071331002061586801"

    },

    "created_at": "2020-03-24T07:13:31.000Z",

    "updated_at": "2020-03-24T07:14:55.000Z"

  }

}, also we need to verify and validate account number for the subscription. Verify Account Number
In a nutshell

The account validation APIs allow merchants to confirm the authenticity of a customer’s account number before sending money to the customer.
Introduction

Before sending money to a customer, you need to ensure the customer’s account details are correct. This is to ensure you aren’t sending money to the wrong person. In order to achieve this, we provide the following APIs:
Name	Availability	Description
Resolve Account Number	Nigeria, Ghana	Used for the confirmation of personal bank accounts
Account Validation	South Africa	Used for the validation of personal and business bank accounts

Account number verification allows you to:

    Confirm a customer’s bank details before creating a transfer recipient
    Automate your KYC process

Resolve Account Number
Gentle reminder

This feature is available to business in Nigeria and Ghana.

The Resolve Account NumberAPI takes the customer’s account number and bank code and returns the account details of the customer. To resolve an account number, make a GET request to the /bank/resolve endpoint:
Hide Response

curl https://api.paystack.co/bank/resolve?account_number=0001234567&bank_code=058

-H "Authorization: Bearer YOUR_SECRET_KEY"

-X GET

{

  "status": true,

  "message": "Account number resolved",

  "data": {

    "account_number": "0001234567",

    "account_name": "Doe Jane Loren",

    "bank_id": 9

  }

}

Pricing

This endpoint is free for use.
Account Validation
Gentle Reminder

This feature is only available to businesses in South Africa.

The Validate AccountAPI allows merchant validate both personal and business accounts. It checks if the provided customer’s details are correct and returns the status of the check. However, not all banks support account verification, so you need to confirm if the customer's bank supports it.
Fetch supported banks

To confirm the banks that supports account validation, make a request to the List BankAPI endpoint, passing the enabled_for_verification query parameter:
Hide Response

curl https://api.paystack.co/bank?currency=ZAR&enabled_for_verification=true

-H "Authorization: Bearer YOUR_SECRET_KEY"

-X GET

{

  "status": true,

  "message": "Banks retrieved",

  "data": [

    {

      "id": 140,

      "name": "Absa Bank Limited, South Africa",

      "slug": "absa-za",

      "code": "632005",

      "longcode": "632005",

      "gateway": null,

      "pay_with_bank": false,

      "active": true,

      "country": "South Africa",

      "currency": "ZAR",

      "type": "basa",

      "is_deleted": false,

      "createdAt": "2020-09-04T10:38:56.000Z",

      "updatedAt": null,

      "supported_types": [

        "business",

        "personal"

      ]

    },

    {

      "id": 141,

      "name": "African Bank Limited",

      "slug": "african-bank-za",

      "code": "430000",

      "longcode": "430000",

      "gateway": null,

      "pay_with_bank": false,

      "active": true,

      "country": "South Africa",

      "currency": "ZAR",

      "type": "basa",

      "is_deleted": false,

      "createdAt": "2020-09-04T10:38:56.000Z",

      "updatedAt": null,

      "supported_types": [

        "business",

        "personal"

      ]

    },

    {

      "id": 146,

      "name": "Capitec Bank Limited",

      "slug": "capitec-bank-za",

      "code": "470010",

      "longcode": "470010",

      "gateway": null,

      "pay_with_bank": false,

      "active": true,

      "country": "South Africa",

      "currency": "ZAR",

      "type": "basa",

      "is_deleted": false,

      "createdAt": "2020-09-04T10:38:56.000Z",

      "updatedAt": null,

      "supported_types": [

        "personal"

      ]

    },

    {

      "id": 147,

      "name": "Discovery Bank Limited",

      "slug": "discovery-bank-za",

      "code": "679000",

      "longcode": "679000",

      "gateway": null,

      "pay_with_bank": false,

      "active": true,

      "country": "South Africa",

      "currency": "ZAR",

      "type": "basa",

      "is_deleted": false,

      "createdAt": "2020-09-04T10:38:56.000Z",

      "updatedAt": null,

      "supported_types": [

        "business",

        "personal"

      ]

    },

    {

      "id": 151,

      "name": "First National Bank",

      "slug": "first-national-bank-za",

      "code": "250655",

      "longcode": "250655",

      "gateway": null,

      "pay_with_bank": false,

      "active": true,

      "country": "South Africa",

      "currency": "ZAR",

      "type": "basa",

      "is_deleted": false,

      "createdAt": "2020-09-04T10:38:56.000Z",

      "updatedAt": null,

      "supported_types": [

        "business",

        "personal"

      ]

    },

    {

      "id": 152,

      "name": "Grindrod Bank",

      "slug": "grindrod-bank-za",

      "code": "584000",

      "longcode": "584000",

      "gateway": null,

      "pay_with_bank": false,

      "active": true,

      "country": "South Africa",

      "currency": "ZAR",

      "type": "basa",

      "is_deleted": false,

      "createdAt": "2020-09-04T10:38:56.000Z",

      "updatedAt": null,

      "supported_types": [

        "business",

        "personal"

      ]

    },

    {

      "id": 153,

      "name": "Investec Bank Ltd",

      "slug": "investec-bank-za",

      "code": "580105",

      "longcode": "580105",

      "gateway": null,

      "pay_with_bank": false,

      "active": true,

      "country": "South Africa",

      "currency": "ZAR",

      "type": "basa",

      "is_deleted": false,

      "createdAt": "2020-09-04T10:38:56.000Z",

      "updatedAt": null,

      "supported_types": [

        "business",

        "personal"

      ]

    },

    {

      "id": 157,

      "name": "Nedbank",

      "slug": "nedbank-za",

      "code": "198765",

      "longcode": "198765",

      "gateway": null,

      "pay_with_bank": false,

      "active": true,

      "country": "South Africa",

      "currency": "ZAR",

      "type": "basa",

      "is_deleted": false,

      "createdAt": "2020-09-04T10:38:56.000Z",

      "updatedAt": null,

      "supported_types": [

        "business",

        "personal"

      ]

    },

    {

      "id": 161,

      "name": "SASFIN Bank",

      "slug": "sasfin-bank-za",

      "code": "683000",

      "longcode": "683000",

      "gateway": null,

      "pay_with_bank": false,

      "active": true,

      "country": "South Africa",

      "currency": "ZAR",

      "type": "basa",

      "is_deleted": false,

      "createdAt": "2020-09-04T10:38:56.000Z",

      "updatedAt": null,

      "supported_types": [

        "business",

        "personal"

      ]

    },

    {

      "id": 163,

      "name": "Standard Bank South Africa",

      "slug": "standard-bank-za",

      "code": "051001",

      "longcode": "051001",

      "gateway": null,

      "pay_with_bank": false,

      "active": true,

      "country": "South Africa",

      "currency": "ZAR",

      "type": "basa",

      "is_deleted": false,

      "createdAt": "2020-09-04T10:38:56.000Z",

      "updatedAt": null,

      "supported_types": [

        "business",

        "personal"

      ]

    },

    {

      "id": 165,

      "name": "TymeBank",

      "slug": "tymebank-za",

      "code": "678910",

      "longcode": "678910",

      "gateway": null,

      "pay_with_bank": false,

      "active": true,

      "country": "South Africa",

      "currency": "ZAR",

      "type": "basa",

      "is_deleted": false,

      "createdAt": "2020-09-04T10:38:56.000Z",

      "updatedAt": null,

      "supported_types": [

        "business",

        "personal"

      ]

    }

  ]

}

The data object in the response contains the banks that support account validation. The supported_types in each bank object contains an array of the account type that can be validated. Some banks only support personal accounts while others support both personal and business accounts. If the customer's bank is returned in this response, then you can go ahead with account validation, else, the account validation can be skipped.
Validate account

To validate an account, make a POST request to the /bank/validate endpoint:
Show Response

curl https://api.paystack.co/bank/validate

-H "Authorization: Bearer YOUR_SECRET_KEY"

-H "Content-Type: application/json"

-d '{ 

      "bank_code": "632005",

      "country_code": "ZA",

      "account_number": "0123456789",

      "account_name": "Ann Bron",

      "account_type": "personal",

      "document_type": "identityNumber",

      "document_number": "1234567890123"

    }'

-X POST

The /bank/validate endpoint can be used for both personal and business account validation by using the following request parameters:
Name	Type	Description
account_name	String	Customer's first and last name registered with their bank
account_number	String	Customer’s account number
account_type	String	This can take one of: [personal, business]
bank_code	String	The bank code of the customer’s bank. You can fetch the bank codes by using our List BankAPI.
country_code	String	The two digit ISO code of the customer’s bank
document_type	String	Customer’s mode of identity. This could be one of: [identityNumber, passportNumber, businessRegistrationNumber]
document_number	String	Customer’s mode of identity number

When validating a personal account number, the customer can either provide their passport or identity number. You can specify the mode of identity by passing either identityNumber or passportNumber as the document_type parameter.

For business account validation the document_type should be businessRegistrationNumber. Initiate Transfer

Send money to your customers.

Status of transfer object returned will be pending if OTP is disabled. In the event that an OTP is required, status will read otp.
Headers
authorization
String
	Set value to Bearer SECRET_KEY
content-type
String
	Set value to application/json
Body Parameters
source
String
	Where should we transfer from? Only balance for now
amount
Integer
	Amount to transfer in kobo if currency is NGN and pesewas if currency is GHS.
recipient
String
	Code for transfer recipient
reason
String
	
The reason for the transfer
currency
String
	
Specify the currency of the transfer. Defaults to NGN
account_reference
String
	
A unique identifier required in Kenya for MPESA Paybill and Till transfers
reference
String
	
If specified, the field should be a unique identifier (in lowercase) for the object. Only -,_ and alphanumeric characters allowed.
Hide optional parameters
POST/transfer
cURL

#!/bin/sh

url="https://api.paystack.co/transfer"

authorization="Authorization: Bearer YOUR_SECRET_KEY"

content_type="Content-Type: application/json"

data='{ 

  "source": "balance", 

  "reason": "Calm down", 

  "amount":3794800, 

  "recipient": "RCP_gx2wn530m0i3w3m"

}'


curl "$url" -H "$authorization" -H "$content_type" -d "$data" -X POST

Sample Response
200 Ok

{

  "status": true,

  "message": "Transfer requires OTP to continue",

  "data": {

    "integration": 100073,

    "domain": "test",

    "amount": 3794800,

    "currency": "NGN",

    "source": "balance",

    "reason": "Calm down",

    "recipient": 28,

    "status": "otp",

    "transfer_code": "TRF_1ptvuv321ahaa7q",

    "id": 14,

    "createdAt": "2017-02-03T17:21:54.508Z",

    "updatedAt": "2017-02-03T17:21:54.508Z"

  }

}

Finalize Transfer

Finalize an initiated transfer
Headers
authorization
String
	Set value to Bearer SECRET_KEY
content-type
String
	Set value to application/json
Body Parameters
transfer_code
String
	The transfer code you want to finalize
otp
String
	OTP sent to business phone to verify transfer
POST/transfer/finalize_transfer
cURL

#!/bin/sh

url="https://api.paystack.co/transfer/finalize_transfer"

authorization="Authorization: Bearer YOUR_SECRET_KEY"

content_type="Content-Type: application/json"

data='{ 

  "transfer_code": "TRF_vsyqdmlzble3uii", 

  "otp": "928783"

}'


curl "$url" -H "$authorization" -H "$content_type" -d "$data" -X POST

Sample Response
200 Ok

{

  "status": true,

  "message": "Transfer has been queued",

  "data": {

    "domain": "test",

    "amount": 1000000,

    "currency": "NGN",

    "reference": "n7ll9pzl6b",

    "source": "balance",

    "source_details": null,

    "reason": "E go better for you",

    "status": "success",

    "failures": null,

    "transfer_code": "TRF_zuirlnr9qblgfko",

    "titan_code": null,

    "transferred_at": null,

    "id": 529410,

    "integration": 123460,

    "recipient": 225204,

    "createdAt": "2018-08-02T10:02:55.000Z",

    "updatedAt": "2018-08-02T10:12:05.000Z"

  }

}

Initiate Bulk Transfer

Batch multiple transfers in a single request.

You need to disable the Transfers OTP requirement to use this endpoint.
Headers
authorization
String
	Set value to Bearer SECRET_KEY
content-type
String
	Set value to application/json
Body Parameters
source
String
	Where should we transfer from? Only balance for now
transfers
Array
	A list of transfer object. Each object should contain amount, recipient, and reference
POST/transfer/bulk
cURL

#!/bin/sh

url="https://api.paystack.co/transfer/bulk"

authorization="Authorization: Bearer YOUR_SECRET_KEY"

content_type="Content-Type: application/json"

data='{ 

  "currency": "NGN",

  "source": "balance",

  "transfers": [

    {

      "amount": 20000,

      "reference": "588YtfftReF355894J",

      "reason": "Why not?",

      "recipient": "RCP_2tn9clt23s7qr28"

    },

    {

      "amount": 30000,

      "reference": "YunoTReF35e0r4J",

      "reason": "Because I can",

      "recipient": "RCP_1a25w1h3n0xctjg"

    },

    {

      "amount": 40000,

      "reason": "Coming right up",

      "recipient": "RCP_aps2aibr69caua7"

    }

  ]

}'


curl "$url" -H "$authorization" -H "$content_type" -d "$data" -X POST

Sample Response
200 Ok

{

  "status": true,

  "message": "3 transfers queued.",

  "data": [

    {

      "reference": "588YtfftReF355894J",

      "recipient": "RCP_2tn9clt23s7qr28",

      "amount": 20000,

      "transfer_code": "TRF_ful4rvpbiuaph4fo",

      "currency": "NGN",

      "status": "received"

    },

    {

      "reference": "YunoTReF35e0r4J",

      "recipient": "RCP_1a25w1h3n0xctjg",

      "amount": 30000,

      "transfer_code": "TRF_0lztrf3rox1rpbw1",

      "currency": "NGN",

      "status": "received"

    },

    {

      "reference": "nm7kjk9gb-l5i4lr9wq3",

      "recipient": "RCP_aps2aibr69caua7",

      "amount": 40000,

      "transfer_code": "TRF_hsk59k6loek7vlut",

      "currency": "NGN",

      "status": "received"

    }

  ]

}

List Transfers

List the transfers made on your integration.
Headers
authorization
String
	Set value to Bearer SECRET_KEY
Query Parameters
perPage
Integer
	Specify how many records you want to retrieve per page. If not specify we use a default value of 50.
page
Integer
	Specify exactly what transfer you want to page. If not specify we use a default value of 1.
recipient
Integer
	Filter by the recipient ID
from
Datetime
	
A timestamp from which to start listing transfer e.g. 2016-09-24T00:00:05.000Z, 2016-09-21
to
Datetime
	
A timestamp at which to stop listing transfer e.g. 2016-09-24T00:00:05.000Z, 2016-09-21
Show optional parameters
GET/transfer
cURL

#!/bin/sh

url="https://api.paystack.co/transfer"

authorization="Authorization: Bearer YOUR_SECRET_KEY"


curl "$url" -H "$authorization" -X GET

Sample Response
200 Ok

{

  "status": true,

  "message": "Transfers retrieved",

  "data": [

    {

      "integration": 100073,

      "recipient": {

        "domain": "test",

        "type": "nuban",

        "currency": "NGN",

        "name": "Flesh",

        "details": {

          "account_number": "olounje",

          "account_name": null,

          "bank_code": "044",

          "bank_name": "Access Bank"

        },

        "description": "Eater",

        "metadata": null,

        "recipient_code": "RCP_2x5j67tnnw1t98k",

        "active": true,

        "id": 28,

        "integration": 100073,

        "createdAt": "2017-02-02T19:39:04.000Z",

        "updatedAt": "2017-02-02T19:39:04.000Z"

      },

      "domain": "test",

      "amount": 4400,

      "currency": "NGN",

      "source": "balance",

      "source_details": null,

      "reason": "Eater",

      "status": "otp",

      "failures": null,

      "transfer_code": "TRF_1ptvuv321ahaa7q",

      "id": 14,

      "createdAt": "2017-02-03T17:21:54.000Z",

      "updatedAt": "2017-02-03T17:21:54.000Z"

    },

    {

      "integration": 100073,

      "recipient": {

        "domain": "test",

        "type": "nuban",

        "currency": "USD",

        "name": "FleshUSD",

        "details": {

          "account_number": "1111111111",

          "account_name": null,

          "bank_code": "044",

          "bank_name": "Access Bank"

        },

        "description": "EaterUSD",

        "metadata": null,

        "recipient_code": "RCP_bi84k5gguakuqmg",

        "active": true,

        "id": 22,

        "integration": 100073,

        "createdAt": "2017-01-23T16:52:48.000Z",

        "updatedAt": "2017-01-23T16:52:48.000Z"

      },

      "domain": "test",

      "amount": 3300,

      "currency": "NGN",

      "source": "balance",

      "source_details": null,

      "reason": "I love you",

      "status": "otp",

      "failures": null,

      "transfer_code": "TRF_5pr8ypzb0htx0cn",

      "id": 13,

      "createdAt": "2017-01-23T16:55:59.000Z",

      "updatedAt": "2017-01-23T16:55:59.000Z"

    }

  ],

  "meta": {

    "total": 2,

    "skipped": 0,

    "perPage": 50,

    "page": 1,

    "pageCount": 1

  }

}

Fetch Transfer

Get details of a transfer on your integration.
Headers
authorization
String
	Set value to Bearer SECRET_KEY
Path Parameters
id_or_code
String
	The transfer ID or code you want to fetch
GET/transfer/:id_or_code
cURL

#!/bin/sh

url="https://api.paystack.co/transfer/{id_or_code}"

authorization="Authorization: Bearer YOUR_SECRET_KEY"


curl "$url" -H "$authorization" -X GET

Sample Response
200 Ok

{

  "status": true,

  "message": "Transfer retrieved",

  "data": {

    "amount": 20000,

    "createdAt": "2024-02-01T08:32:21.000Z",

    "currency": "NGN",

    "domain": "test",

    "failures": null,

    "id": 451930323,

    "integration": 463433,

    "reason": "Life go better for you",

    "reference": "ge-bzrf8u8k2pygxrnqf",

    "source": "balance",

    "source_details": null,

    "status": "success",

    "titan_code": null,

    "transfer_code": "TRF_fpmd0l8uta8upow7",

    "request": 502643104,

    "transferred_at": null,

    "updatedAt": "2024-02-01T08:34:07.000Z",

    "recipient": {

      "active": true,

      "createdAt": "2021-10-21T11:08:04.000Z",

      "currency": "NGN",

      "description": null,

      "domain": "test",

      "email": "jake@jill.com",

      "id": 19643784,

      "integration": 463433,

      "metadata": {

        "custom_fields": [

          {

            "display_name": "Branch Name",

            "variable_name": "branchName",

            "value": "funny place, Alabama"

          },

          {

            "display_name": "Branch ID",

            "variable_name": "branchID",

            "value": "123"

          }

        ]

      },

      "name": "Abbey Baker",

      "recipient_code": "RCP_rjs1szi4ax5hoeo",

      "type": "nuban",

      "updatedAt": "2023-03-29T08:39:39.000Z",

      "is_deleted": false,

      "isDeleted": false,

      "details": {

        "authorization_code": null,

        "account_number": "0123456789",

        "account_name": "Abbey Baker",

        "bank_code": "058",

        "bank_name": "Guaranty Trust Bank"

      }

    },

    "session": {

      "provider": null,

      "id": null

    },

    "fee_charged": 0,

    "fees_breakdown": null,

    "gateway_response": null

  }

}

Verify Transfer

Verify the status of a transfer on your integration.
Headers
authorization
String
	Set value to Bearer SECRET_KEY
Path Parameters
reference
String
	Transfer reference
GET/transfer/verify/:reference
cURL

#!/bin/sh

url="https://api.paystack.co/transfer/verify/{reference}"

authorization="Authorization: Bearer YOUR_SECRET_KEY"


curl "$url" -H "$authorization" -X GET

Sample Response
200 Ok

{

  "status": true,

  "message": "Transfer retrieved",

  "data": {

    "amount": 20000,

    "createdAt": "2024-02-01T08:32:21.000Z",

    "currency": "NGN",

    "domain": "test",

    "failures": null,

    "id": 451930323,

    "integration": 463433,

    "reason": "Life go better for you",

    "reference": "ge-bzrf8u8k2pygxrnqf",

    "source": "balance",

    "source_details": null,

    "status": "success",

    "titan_code": null,

    "transfer_code": "TRF_fpmd0l8uta8upow7",

    "request": 502643104,

    "transferred_at": null,

    "updatedAt": "2024-02-01T08:34:07.000Z",

    "recipient": {

      "active": true,

      "createdAt": "2021-10-21T11:08:04.000Z",

      "currency": "NGN",

      "description": null,

      "domain": "test",

      "email": "jake@jill.com",

      "id": 19643784,

      "integration": 463433,

      "metadata": {

        "custom_fields": [

          {

            "display_name": "Branch Name",

            "variable_name": "branchName",

            "value": "funny place, Alabama"

          },

          {

            "display_name": "Branch ID",

            "variable_name": "branchID",

            "value": "123"

          }

        ]

      },

      "name": "Abbey Baker",

      "recipient_code": "RCP_rjs1szi4ax5hoeo",

      "type": "nuban",

      "updatedAt": "2023-03-29T08:39:39.000Z",

      "is_deleted": false,

      "isDeleted": false,

      "details": {

        "authorization_code": null,

        "account_number": "0123456789",

        "account_name": "Abbey Baker",

        "bank_code": "058",

        "bank_name": "Guaranty Trust Bank"

      }

    },

    "session": {

      "provider": null,

      "id": null

    },

    "fee_charged": 0,

    "fees_breakdown": null,

    "gateway_response": null

  }

}, Subscriptions

The Subscriptions API allows you create and manage recurring payment on your integration.
Create Subscription

Create a subscription on your integration
Headers
authorization
String
	Set value to Bearer SECRET_KEY
content-type
String
	Set value to application/json
Body Parameters
customer
String
	Customer's email address or customer code
plan
String
	Plan code
authorization
String
	If customer has multiple authorizations, you can set the desired authorization you wish to use for this subscription here. If this is not supplied, the customer's most recent authorization would be used
start_date
String
	
Set the date for the first debit. (ISO 8601 format) e.g. 2017-05-16T00:30:13+01:00
Hide optional parameters
POST/subscription
cURL

#!/bin/sh

url="https://api.paystack.co/subscription"

authorization="Authorization: Bearer YOUR_SECRET_KEY"

content_type="Content-Type: application/json"

data='{ 

  "customer": "CUS_xnxdt6s1zg1f4nx", 

  "plan": "PLN_gx2wn530m0i3w3m"

}'


curl "$url" -H "$authorization" -H "$content_type" -d "$data" -X POST

Sample Response
200 Ok

{

  "status": true,

  "message": "Subscription successfully created",

  "data": {

    "customer": 1173,

    "plan": 28,

    "integration": 100032,

    "domain": "test",

    "start": 1459296064,

    "status": "active",

    "quantity": 1,

    "amount": 50000,

    "authorization": {

      "authorization_code": "AUTH_6tmt288t0o",

      "bin": "408408",

      "last4": "4081",

      "exp_month": "12",

      "exp_year": "2020",

      "channel": "card",

      "card_type": "visa visa",

      "bank": "TEST BANK",

      "country_code": "NG",

      "brand": "visa",

      "reusable": true,

      "signature": "SIG_uSYN4fv1adlAuoij8QXh",

      "account_name": "BoJack Horseman"

    },

    "subscription_code": "SUB_vsyqdmlzble3uii",

    "email_token": "d7gofp6yppn3qz7",

    "id": 9,

    "createdAt": "2016-03-30T00:01:04.687Z",

    "updatedAt": "2016-03-30T00:01:04.687Z"

  }

}

List Subscriptions

List subscriptions available on your integration
Headers
authorization
String
	Set value to Bearer SECRET_KEY
Query Parameters
perPage
Integer
	Specify how many records you want to retrieve per page. If not specify we use a default value of 50.
page
Integer
	Specify exactly what page you want to retrieve. If not specify we use a default value of 1.
customer
Integer
	
Filter by Customer ID
plan
Integer
	
Filter by Plan ID
Hide optional parameters
GET/subscription
cURL

#!/bin/sh

url="https://api.paystack.co/subscription"

authorization="Authorization: Bearer YOUR_SECRET_KEY"


curl "$url" -H "$authorization" -X GET

Sample Response
200 Ok

{

  "status": true,

  "message": "Subscriptions retrieved",

  "data": [

    {

      "customer": {

        "first_name": "BoJack",

        "last_name": "Horseman",

        "email": "bojack@horseman.com",

        "phone": "",

        "metadata": null,

        "domain": "test",

        "customer_code": "CUS_hdhye17yj8qd2tx",

        "risk_action": "default",

        "id": 84312,

        "integration": 100073,

        "createdAt": "2016-10-01T10:59:52.000Z",

        "updatedAt": "2016-10-01T10:59:52.000Z"

      },

      "plan": {

        "domain": "test",

        "name": "Weekly small chops",

        "plan_code": "PLN_0as2m9n02cl0kp6",

        "description": "Small chops delivered every week",

        "amount": 27000,

        "interval": "weekly",

        "send_invoices": true,

        "send_sms": true,

        "hosted_page": false,

        "hosted_page_url": null,

        "hosted_page_summary": null,

        "currency": "NGN",

        "migrate": null,

        "id": 1716,

        "integration": 100073,

        "createdAt": "2016-10-01T10:59:11.000Z",

        "updatedAt": "2016-10-01T10:59:11.000Z"

      },

      "integration": 123456,

      "authorization": {

        "authorization_code": "AUTH_6tmt288t0o",

        "bin": "408408",

        "last4": "4081",

        "exp_month": "12",

        "exp_year": "2020",

        "channel": "card",

        "card_type": "visa visa",

        "bank": "TEST BANK",

        "country_code": "NG",

        "brand": "visa",

        "reusable": true,

        "signature": "SIG_uSYN4fv1adlAuoij8QXh",

        "account_name": "BoJack Horseman"

      },

      "domain": "test",

      "start": 1475319599,

      "status": "active",

      "quantity": 1,

      "amount": 27000,

      "subscription_code": "SUB_6phdx225bavuwtb",

      "email_token": "ore84lyuwcv2esu",

      "easy_cron_id": "275226",

      "cron_expression": "0 0 * * 6",

      "next_payment_date": "2016-10-15T00:00:00.000Z",

      "open_invoice": "INV_qc875pkxpxuyodf",

      "id": 4192,

      "createdAt": "2016-10-01T10:59:59.000Z",

      "updatedAt": "2016-10-12T07:45:14.000Z"

    }

  ],

  "meta": {

    "total": 1,

    "skipped": 0,

    "perPage": 50,

    "page": 1,

    "pageCount": 1

  }

}

Fetch Subscription

Get details of a subscription on your integration
Headers
authorization
String
	Set value to Bearer SECRET_KEY
Path Parameters
id_or_code
String
	The subscription ID or code you want to fetch
GET/subscription/:id_or_code
cURL

#!/bin/sh

url="https://api.paystack.co/subscription/{id_or_code}"

authorization="Authorization: Bearer YOUR_SECRET_KEY"


curl "$url" -H "$authorization" -X GET

Sample Response
200 Ok

{

  "status": true,

  "message": "Subscription retrieved successfully",

  "data": {

    "invoices": [],

    "customer": {

      "first_name": "BoJack",

      "last_name": "Horseman",

      "email": "bojack@horsinaround.com",

      "phone": null,

      "metadata": {

        "photos": [

          {

            "type": "twitter",

            "typeId": "twitter",

            "typeName": "Twitter",

            "url": "https://d2ojpxxtu63wzl.cloudfront.net/static/61b1a0a1d4dda2c9fe9e165fed07f812_a722ae7148870cc2e33465d1807dfdc6efca33ad2c4e1f8943a79eead3c21311",

            "isPrimary": false

          }

        ]

      },

      "domain": "test",

      "customer_code": "CUS_xnxdt6s1zg1f4nx",

      "id": 1173,

      "integration": 100032,

      "createdAt": "2016-03-29T20:03:09.000Z",

      "updatedAt": "2016-03-29T20:53:05.000Z"

    },

    "plan": {

      "domain": "test",

      "name": "Monthly retainer (renamed)",

      "plan_code": "PLN_gx2wn530m0i3w3m",

      "description": null,

      "amount": 50000,

      "interval": "monthly",

      "send_invoices": true,

      "send_sms": true,

      "hosted_page": false,

      "hosted_page_url": null,

      "hosted_page_summary": null,

      "currency": "NGN",

      "id": 28,

      "integration": 100032,

      "createdAt": "2016-03-29T22:42:50.000Z",

      "updatedAt": "2016-03-29T23:51:41.000Z"

    },

    "integration": 100032,

    "authorization": {

      "authorization_code": "AUTH_6tmt288t0o",

      "bin": "408408",

      "last4": "4081",

      "exp_month": "12",

      "exp_year": "2020",

      "channel": "card",

      "card_type": "visa visa",

      "bank": "TEST BANK",

      "country_code": "NG",

      "brand": "visa",

      "reusable": true,

      "signature": "SIG_uSYN4fv1adlAuoij8QXh",

      "account_name": "BoJack Horseman"

    },

    "domain": "test",

    "start": 1459296064,

    "status": "active",

    "quantity": 1,

    "amount": 50000,

    "subscription_code": "SUB_vsyqdmlzble3uii",

    "email_token": "d7gofp6yppn3qz7",

    "easy_cron_id": null,

    "cron_expression": "0 0 28 * *",

    "next_payment_date": "2016-04-28T07:00:00.000Z",

    "open_invoice": null,

    "id": 9,

    "createdAt": "2016-03-30T00:01:04.000Z",

    "updatedAt": "2016-03-30T00:22:58.000Z"

  }

}

Enable Subscription

Enable a subscription on your integration
Headers
authorization
String
	Set value to Bearer SECRET_KEY
content-type
String
	Set value to application/json
Body Parameters
code
String
	Subscription code
token
String
	Email token
POST/subscription/enable
cURL

#!/bin/sh

url="https://api.paystack.co/subscription/enable"

authorization="Authorization: Bearer YOUR_SECRET_KEY"

content_type="Content-Type: application/json"

data='{ 

  "code": "SUB_vsyqdmlzble3uii", 

  "token": "d7gofp6yppn3qz7"

}'


curl "$url" -H "$authorization" -H "$content_type" -d "$data" -X POST

Sample Response
200 Ok

{

  "status": true,

  "message": "Subscription enabled successfully"

}

Disable Subscription

Disable a subscription on your integration
Headers
authorization
String
	Set value to Bearer SECRET_KEY
content-type
String
	Set value to application/json
Body Parameters
code
String
	Subscription code
token
String
	Email token
POST/subscription/disable
cURL

#!/bin/sh

url="https://api.paystack.co/subscription/disable"

authorization="Authorization: Bearer YOUR_SECRET_KEY"

content_type="Content-Type: application/json"

data='{ 

  "code": "SUB_vsyqdmlzble3uii", 

  "token": "d7gofp6yppn3qz7" 

}'


curl "$url" -H "$authorization" -H "$content_type" -d "$data" -X POST

Sample Response
200 Ok

{

  "status": true,

  "message": "Subscription disabled successfully"

}

Generate Update Subscription Link

Generate a link for updating the card on a subscription
Headers
authorization
String
	Set value to Bearer SECRET_KEY
Path Parameters
code
String
	Subscription code
GET/subscription/:code/manage/link/
cURL

#!/bin/sh

url="https://api.paystack.co/subscription/{code}/manage/link"

authorization="Authorization: Bearer YOUR_SECRET_KEY"


curl "$url" -H "$authorization" -X GET

Sample Response
200 Ok

{

  "status": true,

  "message": "Link generated",

  "data": {

    "link": "https://paystack.com/manage/subscriptions/qlgwhpyq1ts9nsw?subscription_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWJzY3JpcHRpb25fY29kZSI6IlNVQl9xbGd3aHB5cTB0czluc3ciLCJpbnRlZ3JhdGlvbiI6MzUzNTE0LCJkb21haW4iOiJ0ZXN0IiwiZW1haWxfdG9rZW4iOiJzNXIwZjA0ODdwcnNtZWsiLCJpYXQiOjE2MzUyNTkxMzEsIm5iZiI6MTYzNTI1OTEzcjeR82XhwIjoxNjM1MzQ1NTMxfQ.FK1glvwMjHu9J8P-4n2oXPN_u_fIpQZ-F_s5x_4WLag"

  }

}

Send Update Subscription Link

Email a customer a link for updating the card on their subscription
Headers
authorization
String
	Set value to Bearer SECRET_KEY
Path Parameters
code
String
	Subscription code
POST/subscription/:code/manage/email/
cURL

#!/bin/sh

url="https://api.paystack.co/subscription/{code}/manage/email"

authorization="Authorization: Bearer YOUR_SECRET_KEY"


curl "$url" -H "$authorization" -X POST

Sample Response
200 Ok

{

  "status": true,

  "message": "Email successfully sent"

} this are updated information from paystack documentation, now create a working subscription payment with all the encessary information, now rewrite the codes and subscriptions service without forgwtting any detail supplied in this prompt also noting how a user can check information of subscription,recurring, pause subsription with information saved to database and all that. 